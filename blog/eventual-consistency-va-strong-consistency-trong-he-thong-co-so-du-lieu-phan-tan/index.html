<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Eventual Consistency và Strong Consistency trong hệ thống Cơ sở dữ liệu phân tán | HuyDQ's Blog</title><meta name=keywords content="Database"><meta name=description content="Một Database Transaction, theo như định nghĩa sẽ phải thỏa mãn các tính chất sau: Atomic, Consistency, Isolation và Durable (hay thường được gọi là ACID). Bài viết này sẽ tập trung vào tính chất Consistency (tính nhất quán), và so sánh giữa Eventual Consistency với Strong Consistency trong hệ thống Distributed Databases qua các ví dụ đời thường.
Lý thuyết Distributed Database (hệ thống cơ sở dữ liệu phân tán): Là hệ thống Cơ sở dữ liệu (CSDL) mà có thể được phân tải, lưu trữ ở nhiều nơi."><meta name=author content><link rel=canonical href=https://huydq.dev/blog/eventual-consistency-va-strong-consistency-trong-he-thong-co-so-du-lieu-phan-tan/><link crossorigin=anonymous href=/assets/css/stylesheet.0cc67acd22146733bad9e509decee830163972ec8f8f0baf604dc35feeade5ad.css integrity="sha256-DMZ6zSIUZzO62eUJ3s7oMBY5cuyPjwuvYE3DX+6t5a0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://huydq.dev/icons/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://huydq.dev/icons/favicon16.png><link rel=icon type=image/png sizes=32x32 href=https://huydq.dev/icons/favicon32.png><link rel=apple-touch-icon href=https://huydq.dev/icons/favicon.png><link rel=mask-icon href=https://huydq.dev/icons/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-5KF148C0X6"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5KF148C0X6",{anonymize_ip:!1})}</script><meta property="og:title" content="Eventual Consistency và Strong Consistency trong hệ thống Cơ sở dữ liệu phân tán"><meta property="og:description" content="Một Database Transaction, theo như định nghĩa sẽ phải thỏa mãn các tính chất sau: Atomic, Consistency, Isolation và Durable (hay thường được gọi là ACID). Bài viết này sẽ tập trung vào tính chất Consistency (tính nhất quán), và so sánh giữa Eventual Consistency với Strong Consistency trong hệ thống Distributed Databases qua các ví dụ đời thường.
Lý thuyết Distributed Database (hệ thống cơ sở dữ liệu phân tán): Là hệ thống Cơ sở dữ liệu (CSDL) mà có thể được phân tải, lưu trữ ở nhiều nơi."><meta property="og:type" content="article"><meta property="og:url" content="https://huydq.dev/blog/eventual-consistency-va-strong-consistency-trong-he-thong-co-so-du-lieu-phan-tan/"><meta property="og:image" content="https://huydq.dev/icons/thumbnail.jpg"><meta property="article:section" content="blog"><meta property="article:published_time" content="2018-10-12T00:00:00+00:00"><meta property="article:modified_time" content="2018-10-12T00:00:00+00:00"><meta property="og:site_name" content="HuyDQ's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://huydq.dev/icons/thumbnail.jpg"><meta name=twitter:title content="Eventual Consistency và Strong Consistency trong hệ thống Cơ sở dữ liệu phân tán"><meta name=twitter:description content="Một Database Transaction, theo như định nghĩa sẽ phải thỏa mãn các tính chất sau: Atomic, Consistency, Isolation và Durable (hay thường được gọi là ACID). Bài viết này sẽ tập trung vào tính chất Consistency (tính nhất quán), và so sánh giữa Eventual Consistency với Strong Consistency trong hệ thống Distributed Databases qua các ví dụ đời thường.
Lý thuyết Distributed Database (hệ thống cơ sở dữ liệu phân tán): Là hệ thống Cơ sở dữ liệu (CSDL) mà có thể được phân tải, lưu trữ ở nhiều nơi."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Eventual Consistency và Strong Consistency trong hệ thống Cơ sở dữ liệu phân tán","item":"https://huydq.dev/blog/eventual-consistency-va-strong-consistency-trong-he-thong-co-so-du-lieu-phan-tan/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Eventual Consistency và Strong Consistency trong hệ thống Cơ sở dữ liệu phân tán","name":"Eventual Consistency và Strong Consistency trong hệ thống Cơ sở dữ liệu phân tán","description":"Một Database Transaction, theo như định nghĩa sẽ phải thỏa mãn các tính chất sau: Atomic, Consistency, Isolation và Durable (hay thường được gọi là ACID). Bài viết này sẽ tập trung vào tính chất Consistency (tính nhất quán), và so sánh giữa Eventual Consistency với Strong Consistency trong hệ thống Distributed Databases qua các ví dụ đời thường.\nLý thuyết Distributed Database (hệ thống cơ sở dữ liệu phân tán): Là hệ thống Cơ sở dữ liệu (CSDL) mà có thể được phân tải, lưu trữ ở nhiều nơi.","keywords":["Database"],"articleBody":"Một Database Transaction, theo như định nghĩa sẽ phải thỏa mãn các tính chất sau: Atomic, Consistency, Isolation và Durable (hay thường được gọi là ACID). Bài viết này sẽ tập trung vào tính chất Consistency (tính nhất quán), và so sánh giữa Eventual Consistency với Strong Consistency trong hệ thống Distributed Databases qua các ví dụ đời thường.\nLý thuyết Distributed Database (hệ thống cơ sở dữ liệu phân tán): Là hệ thống Cơ sở dữ liệu (CSDL) mà có thể được phân tải, lưu trữ ở nhiều nơi. Ví dụ như ứng dụng sử dụng nhiều CSDL và các CSDL có thể nằm ở các máy chủ vật lý khác nhau.\nStrong Consistency (tính nhất quán mạnh): Sau khi một cập nhật được diễn ra thì tất cả các lần đọc dữ liệu sau đó đều trả về giá trị mới được cập nhật.\nEventual Consistency (tính nhất quán cuối cùng, là một dạng của tính nhất quán yếu - Weak Consistency): Sau khi một cập nhật được diễn ra, các lần đọc sau đó không đảm bảo sẽ luôn trả về giá trị mới được cập nhật (có thể có lần đọc vẫn trả về dữ liệu cũ). Tuy nhiên sau một khoảng thời gian (đồng bộ giữa các CSDL) thì cuối cùng các lần đọc đều trả về giá trị mới nhất.\nVí dụ đời thường Một anh chàng tên Duy, có sở thích sưu tập phim và toàn bộ những bộ phim anh ta tải được trên mạng đều được lưu vào laptop. Laptop ở đây đóng vai trò như một CSDL.\nDo sợ vào một ngày đẹp trời laptop bị ăn trộm hoặc bị hỏng sẽ làm mất hết toàn bộ phim trong máy nên Duy mua thêm một ổ cứng di động 8TB và một tài khoản Dropbox để sao lưu lại toàn bộ dữ liệu cho an toàn. Lúc này Laptop, ổ cứng di động và tài khoản Dropbox được coi như một hệ CSDL phân tán (theo mô hình Master - Slave).\n1. Eventual Consistency Khi sử dụng nhiều replica (bản sao) cho một CSDL, giả sử có một write request đến một replica (insert, update, delete dữ liệu) thì chúng ta phải làm sao cho các replica còn lại cũng nhận được request tương ứng để đồng bộ dữ liệu.\nViệc đồng bộ dữ liệu này sẽ tốn thời gian (có thể rất nhỏ), nhưng trong khoảng thời gian đó, nếu có một read request đến một replica chưa đồng bộ xong thì request đó sẽ nhận được kết quả cũ hơn (stale data).\nQuay lại ví dụ của Duy:\n  Cứ mỗi tuần vào tối Thứ Sáu Duy sẽ đồng bộ dữ liệu trong laptop với ổ cứng di động.\n  Tối Chủ Nhật, Long là bạn của Duy mượn ổ cứng di động của Duy để xem phim. Lúc này Long có thể lấy luôn ổ cứng mang về và có toàn bộ dữ liệu cho đến lần sao lưu gần nhất (tức là nếu Thứ Bảy hoặc sáng Chủ Nhật Duy download thêm phim thì trong ổ cứng sẽ không có).\n  Sáng Thứ Hai tuần sau, Long trả lại ổ cứng cho Duy và đến tối Chủ Nhật lại mượn tiếp. Thời điểm đó Long sẽ lại có được toàn bộ phim (bao gồm cả những phim chưa kịp đồng bộ trong tuần này).\n  2. Strong Consistency Tương tự như Eventual Consistency, tuy nhiên để đảm bảo tính nhất quán thì trong trường hợp Strong Consistency toàn bộ các replica sẽ bị delay (trạng thái bận) cho đến khi quá trình đồng bộ hoàn tất.\nChỉ đến khi dữ liệu giữa các replica đã nhất quán thì chúng ta mới trả về kết quả cho client, do đó nó sẽ đảm bảo mọi read request đến sau luôn lấy được dữ liệu mới nhất (nhưng thời gian trả về kết quả lâu hơn).\nQuay lại ví dụ của Duy:\n  Cứ mỗi tuần vào tối Thứ Bảy Duy sẽ đồng bộ dữ liệu trong laptop Dropbox.\n  Tối Chủ Nhật, Dương cũng là bạn của Duy xin link Dropbox để tải phim. Lúc này Duy bảo: “Tôi đã share cho ông link qua Slack rồi nhé, nhưng để mai hãy down thì sẽ có phim mới nhất tôi vừa down sáng nay”.\n  Như vậy để có phim mới nhất xem thì Dương sẽ phải chờ một thời gian khá dài để Duy đồng bộ phim lên Dropbox. Thời gian nhanh hay chậm còn tùy thuộc vào dung lượng phim, tốc độ internet, …\n  3. Kết luận Strong Consistency cho phép dữ liệu luôn nhất quán và được cập nhật mới nhất, nhưng nó có độ trễ cao.\nEventual Consistency thì có độ trễ thấp, kết quả trả về nhanh nhưng dữ liệu nhận được có thể không phải mới nhất.\n= Do đó việc thiết kế CSDL hay sử dụng thuộc tính nhất quán nào sẽ tùy vào yêu cầu của từng project cụ thể.\nTham khảo bài viết gốc Eventual vs Strong Consistency in Distributed Databases.\n","wordCount":"846","inLanguage":"en","datePublished":"2018-10-12T00:00:00Z","dateModified":"2018-10-12T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://huydq.dev/blog/eventual-consistency-va-strong-consistency-trong-he-thong-co-so-du-lieu-phan-tan/"},"publisher":{"@type":"Organization","name":"HuyDQ's Blog","logo":{"@type":"ImageObject","url":"https://huydq.dev/icons/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://huydq.dev/ accesskey=h title="huydq.dev (Alt + H)">huydq.dev</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://huydq.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://huydq.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://huydq.dev/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://huydq.dev/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Eventual Consistency và Strong Consistency trong hệ thống Cơ sở dữ liệu phân tán</h1><div class=post-meta><span title="2018-10-12 00:00:00 +0000 UTC">12/10/2018</span>&nbsp;·&nbsp;4 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#lý-thuyết>Lý thuyết</a></li><li><a href=#ví-dụ-đời-thường>Ví dụ đời thường</a><ul><li><a href=#1-eventual-consistency>1. Eventual Consistency</a></li><li><a href=#2-strong-consistency>2. Strong Consistency</a></li><li><a href=#3-kết-luận>3. Kết luận</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Một Database Transaction, theo như định nghĩa sẽ phải thỏa mãn các tính chất sau: <a href=https://en.wikipedia.org/wiki/Atomicity_(database_systems)>Atomic</a>, <a href=https://en.wikipedia.org/wiki/Consistency_(database_systems)>Consistency</a>, <a href=https://en.wikipedia.org/wiki/Isolation_(database_systems)>Isolation</a> và <a href=https://en.wikipedia.org/wiki/Durability_(database_systems)>Durable</a> (hay thường được gọi là <a href=https://en.wikipedia.org/wiki/ACID_(computer_science)>ACID</a>). Bài viết này sẽ tập trung vào tính chất Consistency (tính nhất quán), và so sánh giữa <strong>Eventual Consistency</strong> với <strong>Strong Consistency</strong> trong hệ thống <strong>Distributed Databases</strong> qua các ví dụ đời thường.</p><h2 id=lý-thuyết>Lý thuyết<a hidden class=anchor aria-hidden=true href=#lý-thuyết>#</a></h2><p><strong>Distributed Database</strong> (hệ thống cơ sở dữ liệu phân tán): Là hệ thống Cơ sở dữ liệu (CSDL) mà có thể được phân tải, lưu trữ ở nhiều nơi. Ví dụ như ứng dụng sử dụng nhiều CSDL và các CSDL có thể nằm ở các máy chủ vật lý khác nhau.</p><p><strong>Strong Consistency</strong> (tính nhất quán mạnh): Sau khi một cập nhật được diễn ra thì tất cả các lần đọc dữ liệu sau đó đều trả về giá trị mới được cập nhật.</p><p><strong>Eventual Consistency</strong> (tính nhất quán cuối cùng, là một dạng của tính nhất quán yếu - Weak Consistency): Sau khi một cập nhật được diễn ra, các lần đọc sau đó không đảm bảo sẽ luôn trả về giá trị mới được cập nhật (có thể có lần đọc vẫn trả về dữ liệu cũ). Tuy nhiên sau một khoảng thời gian (đồng bộ giữa các CSDL) thì cuối cùng các lần đọc đều trả về giá trị mới nhất.</p><h2 id=ví-dụ-đời-thường>Ví dụ đời thường<a hidden class=anchor aria-hidden=true href=#ví-dụ-đời-thường>#</a></h2><p>Một anh chàng tên Duy, có sở thích sưu tập phim và toàn bộ những bộ phim anh ta tải được trên mạng đều được lưu vào laptop. Laptop ở đây đóng vai trò như một CSDL.</p><p>Do sợ vào một ngày đẹp trời laptop bị ăn trộm hoặc bị hỏng sẽ làm mất hết toàn bộ phim trong máy nên Duy mua thêm một ổ cứng di động 8TB và một tài khoản Dropbox để sao lưu lại toàn bộ dữ liệu cho an toàn. Lúc này Laptop, ổ cứng di động và tài khoản Dropbox được coi như một hệ CSDL phân tán (theo mô hình Master - Slave).</p><p><img loading=lazy src=/images/master-slave-model.png alt="Master slave data model"></p><h3 id=1-eventual-consistency>1. Eventual Consistency<a hidden class=anchor aria-hidden=true href=#1-eventual-consistency>#</a></h3><p>Khi sử dụng nhiều replica (bản sao) cho một CSDL, giả sử có một write request đến một replica (insert, update, delete dữ liệu) thì chúng ta phải làm sao cho các replica còn lại cũng nhận được request tương ứng để đồng bộ dữ liệu.</p><p>Việc đồng bộ dữ liệu này sẽ tốn thời gian (có thể rất nhỏ), nhưng trong khoảng thời gian đó, nếu có một read request đến một replica chưa đồng bộ xong thì request đó sẽ nhận được kết quả cũ hơn (stale data).</p><p><img loading=lazy src=/images/eventual-consistency.png alt="Eventual consistency"></p><p>Quay lại ví dụ của Duy:</p><ul><li><p>Cứ mỗi tuần vào tối Thứ Sáu Duy sẽ đồng bộ dữ liệu trong laptop với ổ cứng di động.</p></li><li><p>Tối Chủ Nhật, Long là bạn của Duy mượn ổ cứng di động của Duy để xem phim. Lúc này Long có thể lấy luôn ổ cứng mang về và có toàn bộ dữ liệu cho đến lần sao lưu gần nhất (tức là nếu Thứ Bảy hoặc sáng Chủ Nhật Duy download thêm phim thì trong ổ cứng sẽ không có).</p></li><li><p>Sáng Thứ Hai tuần sau, Long trả lại ổ cứng cho Duy và đến tối Chủ Nhật lại mượn tiếp. Thời điểm đó Long sẽ lại có được toàn bộ phim (bao gồm cả những phim chưa kịp đồng bộ trong tuần này).</p></li></ul><h3 id=2-strong-consistency>2. Strong Consistency<a hidden class=anchor aria-hidden=true href=#2-strong-consistency>#</a></h3><p>Tương tự như Eventual Consistency, tuy nhiên để đảm bảo tính nhất quán thì trong trường hợp Strong Consistency toàn bộ các replica sẽ bị delay (trạng thái bận) cho đến khi quá trình đồng bộ hoàn tất.</p><p>Chỉ đến khi dữ liệu giữa các replica đã nhất quán thì chúng ta mới trả về kết quả cho client, do đó nó sẽ đảm bảo mọi read request đến sau luôn lấy được dữ liệu mới nhất (nhưng thời gian trả về kết quả lâu hơn).</p><p><img loading=lazy src=/images/strong-consistency.png alt="Strong consistency"></p><p>Quay lại ví dụ của Duy:</p><ul><li><p>Cứ mỗi tuần vào tối Thứ Bảy Duy sẽ đồng bộ dữ liệu trong laptop Dropbox.</p></li><li><p>Tối Chủ Nhật, Dương cũng là bạn của Duy xin link Dropbox để tải phim. Lúc này Duy bảo: &ldquo;Tôi đã share cho ông link qua Slack rồi nhé, nhưng để mai hãy down thì sẽ có phim mới nhất tôi vừa down sáng nay&rdquo;.</p></li><li><p>Như vậy để có phim mới nhất xem thì Dương sẽ phải chờ một thời gian khá dài để Duy đồng bộ phim lên Dropbox. Thời gian nhanh hay chậm còn tùy thuộc vào dung lượng phim, tốc độ internet, &mldr;</p></li></ul><h3 id=3-kết-luận>3. Kết luận<a hidden class=anchor aria-hidden=true href=#3-kết-luận>#</a></h3><p><strong>Strong Consistency</strong> cho phép dữ liệu luôn nhất quán và được cập nhật mới nhất, nhưng nó có độ trễ cao.</p><p><strong>Eventual Consistency</strong> thì có độ trễ thấp, kết quả trả về nhanh nhưng dữ liệu nhận được có thể không phải mới nhất.</p><p>=> Do đó việc thiết kế CSDL hay sử dụng thuộc tính nhất quán nào sẽ tùy vào yêu cầu của từng project cụ thể.</p><p><em>Tham khảo bài viết gốc <a href=https://hackernoon.com/eventual-vs-strong-consistency-in-distributed-databases-282fdad37cf7>Eventual vs Strong Consistency in Distributed Databases</a>.</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://huydq.dev/tags/database/>Database</a></li></ul><nav class=paginav><a class=prev href=https://huydq.dev/blog/starbucks-khong-su-dung-two-phase-commit/><span class=title>« Prev</span><br><span>Starbucks không sử dụng Two-Phase Commit</span></a>
<a class=next href=https://huydq.dev/blog/nhung-quan-niem-sai-lam-ve-cqrs/><span class=title>Next »</span><br><span>Những quan niệm sai lầm về CQRS</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Eventual Consistency và Strong Consistency trong hệ thống Cơ sở dữ liệu phân tán on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhuydq.dev%2fblog%2feventual-consistency-va-strong-consistency-trong-he-thong-co-so-du-lieu-phan-tan%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Eventual Consistency và Strong Consistency trong hệ thống Cơ sở dữ liệu phân tán on twitter" href="https://twitter.com/intent/tweet/?text=Eventual%20Consistency%20v%c3%a0%20Strong%20Consistency%20trong%20h%e1%bb%87%20th%e1%bb%91ng%20C%c6%a1%20s%e1%bb%9f%20d%e1%bb%af%20li%e1%bb%87u%20ph%c3%a2n%20t%c3%a1n&url=https%3a%2f%2fhuydq.dev%2fblog%2feventual-consistency-va-strong-consistency-trong-he-thong-co-so-du-lieu-phan-tan%2f&hashtags=Database"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a></div></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//huydq-dev.disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2022 HuyDQ's Blog</span>
<span>&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;</span><div class=social-icons><a href=https://github.com/robinhuy><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://codepen.io/robinhuy><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"/><line x1="12" y1="22" x2="12" y2="15.5"/><polyline points="22 8.5 12 15.5 2 8.5"/><polyline points="2 15.5 12 8.5 22 15.5"/><line x1="12" y1="2" x2="12" y2="8.5"/></svg></a><a href=https://stackoverflow.com/users/5229299/robin-huy><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.913 16.041v6.848h17.599v-6.848M7.16 18.696h8.925M7.65 13.937l8.675 1.8M9.214 9.124l8.058 3.758M12.086 4.65l6.849 5.66M15.774 1.111l5.313 7.162"/></svg></a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>