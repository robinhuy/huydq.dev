<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Những quan niệm sai lầm về CQRS | HuyDQ's Blog</title><meta name=keywords content="CQRS,Design Pattern"><meta name=description content="Bài viết được dịch (có chỉnh sửa) từ cuốn Patterns Principles and Practices of Domain Driven Design của Scott Millett và Nick Tune, dành cho những ai đã và đang cần tìm hiểu về CQRS (Command Query Responsibility Segregation). Trong bài viết có sử dụng nhiều thuật ngữ chuyên ngành, mình sẽ dẫn link đến các tài liệu Tiếng Anh tương ứng chứ không dịch (không biết dịch như nào hoặc dịch ra nghe rất củ chuối 😬)."><meta name=author content><link rel=canonical href=https://huydq.dev/blog/nhung-quan-niem-sai-lam-ve-cqrs/><link crossorigin=anonymous href=/assets/css/stylesheet.03fdbd40523cb3f4c70fd773f9652c3a49098f4b3ec0af3be47c955612757bf8.css integrity="sha256-A/29QFI8s/THD9dz+WUsOkkJj0s+wK875HyVVhJ1e/g=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://huydq.dev/icons/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://huydq.dev/icons/favicon16.png><link rel=icon type=image/png sizes=32x32 href=https://huydq.dev/icons/favicon32.png><link rel=apple-touch-icon href=https://huydq.dev/icons/favicon.png><link rel=mask-icon href=https://huydq.dev/icons/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-5KF148C0X6"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5KF148C0X6",{anonymize_ip:!1})}</script><meta property="og:title" content="Những quan niệm sai lầm về CQRS"><meta property="og:description" content="Bài viết được dịch (có chỉnh sửa) từ cuốn Patterns Principles and Practices of Domain Driven Design của Scott Millett và Nick Tune, dành cho những ai đã và đang cần tìm hiểu về CQRS (Command Query Responsibility Segregation). Trong bài viết có sử dụng nhiều thuật ngữ chuyên ngành, mình sẽ dẫn link đến các tài liệu Tiếng Anh tương ứng chứ không dịch (không biết dịch như nào hoặc dịch ra nghe rất củ chuối 😬)."><meta property="og:type" content="article"><meta property="og:url" content="https://huydq.dev/blog/nhung-quan-niem-sai-lam-ve-cqrs/"><meta property="og:image" content="https://huydq.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2018-10-12T00:00:00+00:00"><meta property="article:modified_time" content="2018-10-12T00:00:00+00:00"><meta property="og:site_name" content="HuyDQ's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://huydq.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Những quan niệm sai lầm về CQRS"><meta name=twitter:description content="Bài viết được dịch (có chỉnh sửa) từ cuốn Patterns Principles and Practices of Domain Driven Design của Scott Millett và Nick Tune, dành cho những ai đã và đang cần tìm hiểu về CQRS (Command Query Responsibility Segregation). Trong bài viết có sử dụng nhiều thuật ngữ chuyên ngành, mình sẽ dẫn link đến các tài liệu Tiếng Anh tương ứng chứ không dịch (không biết dịch như nào hoặc dịch ra nghe rất củ chuối 😬)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Những quan niệm sai lầm về CQRS","item":"https://huydq.dev/blog/nhung-quan-niem-sai-lam-ve-cqrs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Những quan niệm sai lầm về CQRS","name":"Những quan niệm sai lầm về CQRS","description":"Bài viết được dịch (có chỉnh sửa) từ cuốn Patterns Principles and Practices of Domain Driven Design của Scott Millett và Nick Tune, dành cho những ai đã và đang cần tìm hiểu về CQRS (Command Query Responsibility Segregation). Trong bài viết có sử dụng nhiều thuật ngữ chuyên ngành, mình sẽ dẫn link đến các tài liệu Tiếng Anh tương ứng chứ không dịch (không biết dịch như nào hoặc dịch ra nghe rất củ chuối 😬).","keywords":["CQRS","Design Pattern"],"articleBody":"Bài viết được dịch (có chỉnh sửa) từ cuốn Patterns Principles and Practices of Domain Driven Design của Scott Millett và Nick Tune, dành cho những ai đã và đang cần tìm hiểu về CQRS (Command Query Responsibility Segregation). Trong bài viết có sử dụng nhiều thuật ngữ chuyên ngành, mình sẽ dẫn link đến các tài liệu Tiếng Anh tương ứng chứ không dịch (không biết dịch như nào hoặc dịch ra nghe rất củ chuối 😬).\n1. CQRS rất khó Xét về mức cơ bản thì CQRS chỉ là một pattern đơn giản triển khai nguyên tắc Single Responsibility Principle (SRP) ở lớp Domain Model.\nCQRS không phải là một framework hay là một hệ thống multiple database, nó là pattern được áp dụng vào bounded context, dùng để chia Domain Model thành 2 model: Write Model (Command side) và Read Model (Query side), chúng được xử lý riêng rẽ để đạt hiệu quả tốt hơn.\nCQRS thiên về khái niệm, tư tưởng hơn là một tập hợp các nguyên tắc và pattern phức tạp mà bạn phải tuân theo.\n2. CQRS là Eventually Consistent Eventually Consistency được áp dụng để Read Model được cập nhật bất đồng bộ (asynchronous) với Write Model (sẽ có một bài viết khác giải thích chi tiết hơn về Eventually Consistency).\nĐây không phải là điều kiện tiên quyết của CQRS, nhưng nó thường được sử dụng để cho phép bên Read side có thể scale (mở rộng) dễ dàng.\nCQRS không yêu cầu bạn phải thực hiện Eventually Consistent. Bạn có thể sử dụng cùng một database và transaction để cập nhật Read Model hoặc sử dụng caching để có Strong Consistency.\n3. Model phải dùng Event Sourcing Event Sourcing là một cách rất hiệu quả để xây dựng cả Read Model và Write Model nhưng nó không bắt buộc phải có khi sử dụng CQRS.\nEvent Sourcing là một giải pháp lưu trữ dữ liệu theo lịch sử một cách chính xác, nhưng nó cũng giúp xây dựng Read Model dễ dàng hơn bởi vì bạn có thể tạo ra bất kỳ projection mong muốn từ những dữ liệu sự kiện theo lịch sử.\n4. Command nên là Asynchronous CQRS không bắt buộc Command phải được gửi theo kiểu fire-and-forget (không quan tâm đến response).\nVới các trường hợp tương tác cao, nhiều user thực hiện thay đổi vào cùng dữ liệu thì Asynchronous Command sẽ hiệu quả. Nó sẽ giúp ứng dụng dễ scale và không bị quá tải.\nTuy nhiên các Command mà không phản hồi lại thành công hay thất bại sẽ cần phải có những cách khác để cập nhật cho user kết quả của hành động. Nó có thể là qua email hoặc qua các thao tác phụ xử lý message lỗi.\n5. CQRS chỉ hoạt động được với hệ thống Messaging Nếu bạn đang tìm cách áp dụng một Read store theo cách eventually consistent hoặc xử lý Command theo kiểu bất đồng bộ thì dùng một messaging framework có thể là một ý tưởng tốt.\nNgược lại, sử dụng một hệ thống messaging khi không cần thiết sẽ làm cho ứng dụng của bạn trở nên phức tạp và khó bảo trì hơn.\n6. Cần phải sử dụng Domain Event với CQRS Sử dụng Event để dựng Read Model là một phương pháp hiệu quả để giữ Read Model và Write Model được tách biệt.\nTuy nhiên nó không phải là cách duy nhất, và bạn có thể sử dụng nhiều method khác để tạo Read store, ví dụ như dựng trực tiếp từ dữ liệu quan hệ của Write Model.\nHy vọng những chú ý trên đây sẽ giúp các bạn xây dựng hệ thống sử dụng CQRS một cách chính xác hơn, phù hợp với yêu cầu của ứng dụng.\n","wordCount":"639","inLanguage":"en","datePublished":"2018-10-12T00:00:00Z","dateModified":"2018-10-12T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://huydq.dev/blog/nhung-quan-niem-sai-lam-ve-cqrs/"},"publisher":{"@type":"Organization","name":"HuyDQ's Blog","logo":{"@type":"ImageObject","url":"https://huydq.dev/icons/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://huydq.dev/ accesskey=h title="huydq.dev (Alt + H)">huydq.dev</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://huydq.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://huydq.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://huydq.dev/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://huydq.dev/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Những quan niệm sai lầm về CQRS</h1><div class=post-meta><span title="2018-10-12 00:00:00 +0000 UTC">12/10/2018</span>&nbsp;·&nbsp;3 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-cqrs-rất-khó>1. CQRS rất khó</a></li><li><a href=#2-cqrs-là-eventually-consistent>2. CQRS là Eventually Consistent</a></li><li><a href=#3-model-phải-dùng-event-sourcing>3. Model phải dùng Event Sourcing</a></li><li><a href=#4-command-nên-là-asynchronous>4. Command nên là Asynchronous</a></li><li><a href=#5-cqrs-chỉ-hoạt-động-được-với-hệ-thống-messaging>5. CQRS chỉ hoạt động được với hệ thống Messaging</a></li><li><a href=#6-cần-phải-sử-dụng-domain-event-với-cqrs>6. Cần phải sử dụng Domain Event với CQRS</a></li></ul></nav></div></details></div><div class=post-content><p>Bài viết được dịch (có chỉnh sửa) từ cuốn <a href=https://www.amazon.com/Patterns-Principles-Practices-Domain-Driven-Design/dp/1118714709>Patterns Principles and Practices of Domain Driven Design</a> của Scott Millett và Nick Tune, dành cho những ai đã và đang cần tìm hiểu về <a href=https://martinfowler.com/bliki/CQRS.html>CQRS</a> (Command Query Responsibility Segregation). Trong bài viết có sử dụng nhiều thuật ngữ chuyên ngành, mình sẽ dẫn link đến các tài liệu Tiếng Anh tương ứng chứ không dịch (không biết dịch như nào hoặc dịch ra nghe rất củ chuối 😬).</p><h2 id=1-cqrs-rất-khó>1. CQRS rất khó<a hidden class=anchor aria-hidden=true href=#1-cqrs-rất-khó>#</a></h2><p>Xét về mức cơ bản thì CQRS chỉ là một pattern đơn giản triển khai nguyên tắc <a href=https://en.wikipedia.org/wiki/Single_responsibility_principle>Single Responsibility Principle</a> (SRP) ở lớp <a href=https://en.wikipedia.org/wiki/Domain_model>Domain Model</a>.</p><p>CQRS không phải là một <em>framework</em> hay là một hệ thống <em>multiple database</em>, nó là pattern được áp dụng vào <a href=https://martinfowler.com/bliki/BoundedContext.html>bounded context</a>, dùng để chia Domain Model thành 2 model: Write Model (Command side) và Read Model (Query side), chúng được xử lý riêng rẽ để đạt hiệu quả tốt hơn.</p><p><img loading=lazy src=/images/cqrs-architecture.png alt="CQRS Architecture"></p><p>CQRS thiên về khái niệm, tư tưởng hơn là một tập hợp các nguyên tắc và pattern phức tạp mà bạn phải tuân theo.</p><h2 id=2-cqrs-là-eventually-consistent>2. CQRS là Eventually Consistent<a hidden class=anchor aria-hidden=true href=#2-cqrs-là-eventually-consistent>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Eventual_consistency>Eventually Consistency</a> được áp dụng để Read Model được cập nhật bất đồng bộ (asynchronous) với Write Model (sẽ có một bài viết khác giải thích chi tiết hơn về Eventually Consistency).</p><p>Đây không phải là điều kiện tiên quyết của CQRS, nhưng nó thường được sử dụng để cho phép bên Read side có thể scale (mở rộng) dễ dàng.</p><p>CQRS không yêu cầu bạn phải thực hiện Eventually Consistent. Bạn có thể sử dụng cùng một database và transaction để cập nhật Read Model hoặc sử dụng caching để có Strong Consistency.</p><h2 id=3-model-phải-dùng-event-sourcing>3. Model phải dùng Event Sourcing<a hidden class=anchor aria-hidden=true href=#3-model-phải-dùng-event-sourcing>#</a></h2><p><a href=https://martinfowler.com/eaaDev/EventSourcing.html>Event Sourcing</a> là một cách rất hiệu quả để xây dựng cả Read Model và Write Model nhưng nó không bắt buộc phải có khi sử dụng CQRS.</p><p>Event Sourcing là một giải pháp lưu trữ dữ liệu theo lịch sử một cách chính xác, nhưng nó cũng giúp xây dựng Read Model dễ dàng hơn bởi vì bạn có thể tạo ra bất kỳ <a href=https://abdullin.com/post/event-sourcing-projections/>projection</a> mong muốn từ những dữ liệu sự kiện theo lịch sử.</p><p><img loading=lazy src=/images/cqrs-event-sourcing.png alt="CQRS Event sourcing"></p><h2 id=4-command-nên-là-asynchronous>4. Command nên là Asynchronous<a hidden class=anchor aria-hidden=true href=#4-command-nên-là-asynchronous>#</a></h2><p>CQRS không bắt buộc Command phải được gửi theo kiểu <em>fire-and-forget</em> (không quan tâm đến response).</p><p>Với các trường hợp tương tác cao, nhiều user thực hiện thay đổi vào cùng dữ liệu thì Asynchronous Command sẽ hiệu quả. Nó sẽ giúp ứng dụng dễ scale và không bị quá tải.</p><p>Tuy nhiên các Command mà không phản hồi lại thành công hay thất bại sẽ cần phải có những cách khác để cập nhật cho user kết quả của hành động. Nó có thể là qua email hoặc qua các thao tác phụ xử lý message lỗi.</p><h2 id=5-cqrs-chỉ-hoạt-động-được-với-hệ-thống-messaging>5. CQRS chỉ hoạt động được với hệ thống Messaging<a hidden class=anchor aria-hidden=true href=#5-cqrs-chỉ-hoạt-động-được-với-hệ-thống-messaging>#</a></h2><p>Nếu bạn đang tìm cách áp dụng một Read store theo cách <em>eventually consistent</em> hoặc xử lý Command theo kiểu bất đồng bộ thì dùng một <em>messaging framework</em> có thể là một ý tưởng tốt.</p><p><img loading=lazy src=/images/messaging-queue.png alt="Messaging system"></p><p>Ngược lại, sử dụng một hệ thống messaging khi không cần thiết sẽ làm cho ứng dụng của bạn trở nên phức tạp và khó bảo trì hơn.</p><h2 id=6-cần-phải-sử-dụng-domain-event-với-cqrs>6. Cần phải sử dụng Domain Event với CQRS<a hidden class=anchor aria-hidden=true href=#6-cần-phải-sử-dụng-domain-event-với-cqrs>#</a></h2><p>Sử dụng Event để dựng Read Model là một phương pháp hiệu quả để giữ Read Model và Write Model được tách biệt.</p><p>Tuy nhiên nó không phải là cách duy nhất, và bạn có thể sử dụng nhiều method khác để tạo Read store, ví dụ như dựng trực tiếp từ dữ liệu quan hệ của Write Model.</p><p><em>Hy vọng những chú ý trên đây sẽ giúp các bạn xây dựng hệ thống sử dụng CQRS một cách chính xác hơn, phù hợp với yêu cầu của ứng dụng.</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://huydq.dev/tags/cqrs/>CQRS</a></li><li><a href=https://huydq.dev/tags/design-pattern/>Design Pattern</a></li></ul><nav class=paginav><a class=prev href=https://huydq.dev/blog/cach-tao-mot-trang-blog-ca-nhan-mien-phi-danh-cho-dev/><span class=title>« Prev</span><br><span>Cách tạo một trang blog cá nhân miễn phí dành cho dev</span></a>
<a class=next href=https://huydq.dev/blog/cookies-va-van-de-bao-mat/><span class=title>Next »</span><br><span>Cookies và vấn đề bảo mật</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Những quan niệm sai lầm về CQRS on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhuydq.dev%2fblog%2fnhung-quan-niem-sai-lam-ve-cqrs%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Những quan niệm sai lầm về CQRS on twitter" href="https://twitter.com/intent/tweet/?text=Nh%e1%bb%afng%20quan%20ni%e1%bb%87m%20sai%20l%e1%ba%a7m%20v%e1%bb%81%20CQRS&url=https%3a%2f%2fhuydq.dev%2fblog%2fnhung-quan-niem-sai-lam-ve-cqrs%2f&hashtags=CQRS%2cDesignPattern"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a></div></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//huydq-dev.disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2022 HuyDQ's Blog</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>