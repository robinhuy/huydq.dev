[{"content":"Vào một ngày đẹp trời, bỗng dưng mình nảy ra ý định làm một trang blog cá nhân thay vì viết Blog trên các nền tảng có sẵn như viblo.asia, techmaster.vn, kipalog.vn, \u0026hellip; Tất nhiên các bài viết mới vẫn sẽ đăng lên các nền tảng này để kiếm người đọc chứ blog này ma nó đọc 😅).\nÝ tưởng có rồi, nhưng thực hiện như nào, sử dụng công nghệ nào, chi phí như nào? Khá nhiều câu hỏi đau đầu và khó lựa chọn. Vậy cần đặt ra một số tiêu chí:\n Ưu tiên số một là chi phí, càng rẻ càng tốt, miễn phí thì còn tốt hơn nữa. Sử dụng công nghệ nào cũng được miễn là cài đặt nhanh, dễ dùng, dễ tùy biến. Blog có thể lượng truy cập ít (thậm chí không có ma nào xem), nhưng tốc độ truy cập vẫn phải nhanh, PageSpeed Insights điểm càng cao càng tốt.  Sau một hồi search Google với 3 tiêu chí trên (chủ yếu là tiêu chí miễn phí) thì mình chọn ra được giải pháp như sau:\n Sử dụng Static Site Generator, chơi web tĩnh thì tốc độ sẽ nhanh và điểm PageSpeed Insights sẽ cao. Cụ thể mình dùng tool Hugo. Hosting ở đâu? Tất nhiên là Github Page rồi, free, không giới hạn dung lượng và tốc độ cao. Các bạn cũng có thể dùng một số hosting free khác như: Netlify, Firebase, Vercel, \u0026hellip;  OK. Let\u0026rsquo;s get started!\nCài đặt và sử dụng Hugo Vào trang chủ của Hugo rồi làm theo hướng dẫn cài đặt tùy theo hệ điều hành mà bạn đang sử dụng thôi: https://gohugo.io/getting-started/installing.\nSau khi cài xong thì bật terminal lên và gõ lệnh sau để tạo một project web tĩnh (ví dụ huydq.dev):\nhugo new site huydq.dev Cấu trúc project tạo bởi Hugo như sau:\nTrong đó chúng ta chỉ cần chú ý đến mấy thư mục và file chính:\n content: Nơi viết nội dung cho website, là các file markdown, mỗi file tương ứng 1 trang trong website. theme: Chứa các theme có sẵn tải trên mạng về để làm giao diện cho website. config.toml: File cấu hình cho website như tên website, sử dụng theme gì, \u0026hellip; Có thể đổi sang định dạng yml hoặc yaml nếu không quen với toml.  Tiếp đến chúng ta vào trang này và chọn 1 cái theme ưng ý để cài. Có thể cài bằng cách download file về và ném vào trong thư mục themes hoặc là dùng git submodule để clone qua Github, ví dụ cài theme ananke qua Github:\ncd huydq.dev git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke Cài xong theme thì cần khai báo sử dụng ở trong file config, ví dụ:\nbaseURL = \u0026#34;https://huydq.dev/\u0026#34; title = \u0026#34;HuyDQ\u0026#39;s Blog\u0026#34; theme = \u0026#34;ananke\u0026#34; Trong này cũng cho phép khai báo cấu hình cho theme, cái này là tùy từng theme nên dùng theme nào thì xem ở hướng dẫn của theme đó.\nCấu hình xong theme thì chúng ta có thể bắt đầu viết blog bằng cách gõ lệnh sau để tạo ra một file markdown trong thư mục content (my-first-post.md):\nhugo new posts/my-first-post.md File mới tạo sẽ trông dạng như sau:\n--- title: \u0026#34;My First Post\u0026#34; date: 2019-03-26T08:47:11+01:00 draft: true --- Trong đó có cấu hình tên bài viết (title), ngày xuất bản (date), bản nháp hay đã sẵn sàng xuất bản (draft). Nội dung bài viết thì viết bằng cú pháp markdown, viết sau phần dấu gạch ngang ---. Bài viết nào có đánh dấu draft: true thì sẽ không được build.\nChạy thử website trên local bằng lệnh hugo server, truy cập http://localhost:1313 để xem kết quả. Đường dẫn của trang sẽ tương ứng với đường dẫn file http://localhost:1313/posts/my-first-post. Khi đã thấy ưng ý thì build ra static files (HTML CSS JS) bằng lệnh hugo. Website sẽ được build vào trong thư mục public và chỉ cần đẩy lên 1 hosting hỗ trợ static web là xong.\nCấu hình Github Pages Để sử dụng Github Pages hosting static web thì chúng ta tạo 1 repository trùng với tên miền free của Github Pages theo dạng [username].github.io, ví dụ username github của mình là robinhuy vậy mình sẽ tạo 1 repository là robinhuy.github.io (đây cũng chính là tên miền free của Github Pages).\nChúng ta có thể build website bằng Hugo, sau đó copy code web tĩnh ở trong thư mục public vào trong repository này và push code lên là xong.\nTuy nhiên nếu muốn quản lý cả source code thì chúng ta có thể đẩy toàn bộ project lên (bao gồm cả bản build). Và bản build sẽ được đẩy sang 1 branch là gh-pages, chúng ta sẽ cấu hình Github Pages bằng branch này.\nĐể cho tiện mình sử dụng thêm Github Actions cho việc tự động đẩy bản build sang branch gh-pages bằng cách tạo file .github/workflows/github-actions.yml trong project với nội dung như sau:\nname: GitHub Actions on: [push] jobs: deploy-website: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public Chỉ đơn giản vậy thôi, mỗi lần chúng ta push code lên branch main thì nó sẽ tự động đẩy code trong thư mục public sang branch gh-pages và website của chúng ta sẽ được cập nhật theo.\nChốt lại các thao tác khi cần viết bài mới sẽ là:\n   Tạo 1 file mới trong thư mục content, cấu hình nội dung trang và viết bài theo cú pháp markdown. Dùng lệnh hugo server để chạy website local (có sẵn live reload để tiện preview). Hoặc nếu muốn trải nghiệm viết bài như một CMS thì các bạn có thể cài thêm một số phần mềm theo hướng dẫn sau: https://gohugo.io/tools/frontends/.    Build website bằng lệnh hugo.    Commit code và push lên branch main.    Phần cấu hình website, cấu hình theme, \u0026hellip; thì các bạn tự tìm hiểu nốt trên trang chủ của Hugo và tài liệu hướng dẫn của theme mà bạn chọn nhé. Chúc các bạn viết Blog vui vẻ 😬\n","permalink":"https://huydq.dev/blog/cach-tao-mot-trang-blog-ca-nhan-mien-phi-danh-cho-dev/","summary":"Vào một ngày đẹp trời, bỗng dưng mình nảy ra ý định làm một trang blog cá nhân thay vì viết Blog trên các nền tảng có sẵn như viblo.asia, techmaster.vn, kipalog.vn, \u0026hellip; Tất nhiên các bài viết mới vẫn sẽ đăng lên các nền tảng này để kiếm người đọc chứ blog này ma nó đọc 😅).\nÝ tưởng có rồi, nhưng thực hiện như nào, sử dụng công nghệ nào, chi phí như nào?","title":"Cách tạo một trang blog cá nhân miễn phí dành cho dev"},{"content":"Các phần trước:\nPhần 1: Packages, variables và functions.\nPhần 2: Điều khiển luồng với if, else, switch và defer.\nPhần 3: Arrays và Slices.\nPhần 4: Structs và Maps.\nMethods Trong Go không có class, chúng ta có thể dùng struct thay cho class như ở phần trước. Tuy nhiên trong struct mới chỉ có thuộc tính chứ chưa có phương thức. Để ứng dụng được phương thức (method) như các ngôn ngữ hướng đối tượng khác ta sẽ cần khai báo function kèm theo một tham số đặc biệt gọi là receiver argument. Receiver argument nằm ở giữa từ khóa func và tên của function, nó sẽ chỉ ra một type(thường là một struct) để áp dụng hàm này làm phương thức. Ví dụ:\npackage main  import (  \u0026#34;fmt\u0026#34;  \u0026#34;math\u0026#34; )  // Định nghĩa struct Vertex với 2 thuộc tính X và Y type Vertex struct {  X, Y float64 }  // Tạo phương thức Abs() cho struct Vertex (receiver argument) func (v Vertex) Abs() float64 {  return math.Sqrt(v.X*v.X + v.Y*v.Y) }  func main() {  // Khởi tạo struct  v := Vertex{3, 4}   // Gọi phương thức Abs() của struct  fmt.Println(v.Abs()) } Interfaces Interface là một định nghĩa các tập hợp phương thức mà một đối tượng cần tuân thủ (tương tự như ở trong các ngôn ngữ hướng đối tượng khác). Khi một type có chứa các phương thức như đã khai báo trong interface thì nó đang triển khai (implement) interface đó. Ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  // Định nghĩa interface I với 1 method là M() type I interface {  M() }  // Định nghĩa struct T với 1 field là S kiểu string type T struct {  S string }  // Định nghĩa phương thức M() cho struct T // Struct T sẽ tự động implement interface I func (t T) M() {  fmt.Println(t.S) }  func main() {  // Khởi tạo biến i có kiểu là interface I  var i I = T{\u0026#34;hello\u0026#34;}   // Gọi phương thức M()  i.M() } Type đã triển khai interface buộc phải có đầy đủ các method được định nghĩa trong interface. Ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  // Định nghĩa interface I với 1 method là M() và N() type I interface {  M(),  N() }  // Định nghĩa struct T type T struct {  S string }  // Định nghĩa phương thức M() cho struct T // Struct T sẽ tự động implement interface I func (t T) M() {  fmt.Println(t.S) }  func main() {  // Khởi tạo biến i có kiểu là interface I  var i I = T{\u0026#34;hello\u0026#34;}   // Gọi phương thức M()  i.M()   // Kết quả sẽ báo lỗi vì struct T implement interface I,  // nhưng không có đủ các method đã khai báo (thiếu method N()) } Một interface mà không có chứa method nào thì gọi là interface rỗng ( Emtpy Interface). Interface rỗng có thể lưu mọi loại dữ liệu nên thường được dùng trong trường hợp các hàm xử lý mà cần tham số động (không biết trước kiểu dữ liệu). Ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar i interface{} // i là một empty interface   // Họi hàm describe với tham số truyền vào là một số \ti = 42 \tdescribe(i)   // Họi hàm describe với tham số truyền vào là một chuỗi \ti = \u0026#34;hello\u0026#34; \tdescribe(i) }  // Hàm describe có tham số truyền vào là một empty interface // do đó khi thực thi ta có thể truyền vào kiểu dữ liệu nào cũng được func describe(i interface{}) { \tfmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, i, i) } Series Học Go cấp tốc sẽ tạm dừng ở đây. Mục đích là để các bạn làm quen và nắm được tổng quan của ngôn ngữ Go. Sẽ có một Series khác hướng dẫn chi tiết hơn về lập trình Golang dành cho những ai muốn tìm hiểu sâu hơn để áp dụng vào công việc thực tế.\nHappy coding 😎\n","permalink":"https://huydq.dev/blog/hoc-go-cap-toc-phan-5-methods-va-interfaces/","summary":"Các phần trước:\nPhần 1: Packages, variables và functions.\nPhần 2: Điều khiển luồng với if, else, switch và defer.\nPhần 3: Arrays và Slices.\nPhần 4: Structs và Maps.\nMethods Trong Go không có class, chúng ta có thể dùng struct thay cho class như ở phần trước. Tuy nhiên trong struct mới chỉ có thuộc tính chứ chưa có phương thức. Để ứng dụng được phương thức (method) như các ngôn ngữ hướng đối tượng khác ta sẽ cần khai báo function kèm theo một tham số đặc biệt gọi là receiver argument.","title":"Học Go cấp tốc Phần 5:  Methods và Interfaces"},{"content":"Các phần trước:\nPhần 1: Packages, variables và functions.\nPhần 2: Điều khiển luồng với if, else, switch và defer.\nPhần 3: Arrays và Slices.\nStructs Tương tự C, một struct trong Go là tập hợp các trường (field) do người dùng tự định nghĩa. Mỗi trường có thể có kiểu dữ liệu khác nhau, thậm chí có thể là một struct. Trong Go không có class như các ngôn ngữ hướng đối tượng, do đó chúng ta có thể dùng struct thay cho class. Ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  // Định nghĩa một struct với từ khóa type type Student struct { \tname string \tage int }  func main() {  // Khởi tạo biến s1 có giá trị là struct Student  s1 := Student{\u0026#34;Robin\u0026#34;, 30} // {\u0026#34;Robin\u0026#34;, 30}   // Khởi tạo biến s2 có giá trị là struct Student với 1 field là name  // Field còn lại sẽ có giá trị mặc định (zero value)  s2 := Student{name: \u0026#34;Robin\u0026#34;} // {\u0026#34;Robin\u0026#34;, 0}   // Khởi tạo biến s3 có giá trị là struct Student và không khai báo giá trị cho trường nào  s3 := Student{} // {\u0026#34;\u0026#34;, 0}   // Thay đổi giá trị field trong struct  s3.name = \u0026#34;Robert\u0026#34;  s3.age = 25   fmt.Println(s3) // s3 = {\u0026#34;Robert\u0026#34;, 25} } Struct có thể so sánh được nếu các field của nó có thể so sánh được, và 2 biến kiểu struct có giá trị giống nhau nếu toàn bộ các field có giá trị giống nhau:\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  type Student struct { \tname string \tage int }  func main() { \ts1 := Student{\u0026#34;Steve\u0026#34;, 30} \ts2 := Student{\u0026#34;Steve\u0026#34;, 30}  s3 := Student{\u0026#34;Job\u0026#34;, 30}  \tif s1 == s2 { \tfmt.Println(\u0026#34;s1 = s2\u0026#34;) // s1 bằng s2 \t} else { \tfmt.Println(\u0026#34;s1 != s2\u0026#34;) \t}  \tif s2 == s3 { \tfmt.Println(\u0026#34;s2 = s3\u0026#34;) \t} else { \tfmt.Println(\u0026#34;s2 != s3\u0026#34;) // s2 khác s3 \t} } Maps Map là một tập hợp các phần tử được lưu trữ dưới dạng key - value. Key trong map có kiểu dữ liệu so sánh được và không bị trùng lặp . Để tạo map ta dùng hàm make() với công thức như sau:\nmake(map[type of key]type of value // Định nghĩa biến demoMap có kiểu dữ liệu map với key kiểu string và value kiểu int var demoMap map[string]int  // Map không so sánh được như struct, nhưng có thể dùng toán tử == để kiểm tra nil if demoMap == nil {  fmt.Println(\u0026#34;Map có giá trị nil.\u0026#34;)   // Tạo Map bằng hàm make  demoMap = make(map[string]int) } Thêm phần tử hoặc thay đổi giá trị của một phần tử trong map m ta dùng công thức:\nm[key] = value // Khởi tạo map languages := make(map[string]float32)  // Thêm phần tử vào map languages[\u0026#34;go\u0026#34;] = 0.63 languages[\u0026#34;java\u0026#34;] = 1.03  // Cập nhật lại giá trị của phần tử \u0026#34;go\u0026#34; languages[\u0026#34;go\u0026#34;] = 0.73  fmt.Println(languages) // map[go:0.73 java:1.03] Để xóa phần tử trong map thì ta dùng hàm delete() và cung cấp key của phần tử cần xóa. Ví dụ xóa phần tử có key = \u0026ldquo;go\u0026rdquo; trong map languages:\ndelete(languages, \u0026#34;go\u0026#34;) Để truy xuất đến phần tử trong map, ta gọi map kèm theo key của phần tử. Nếu key đó không tồn tại thì ta sẽ thu được giá trị là zero value (tùy theo kiểu dữ liệu). Ví dụ:\nm := make(map[string]int)  m[\u0026#34;Answer\u0026#34;] = 42 fmt.Println(m[\u0026#34;Answer\u0026#34;]) // Lấy giá trị của phần tử có key = \u0026#34;Answer\u0026#34;, kết quả là 42  delete(m, \u0026#34;Answer\u0026#34;) fmt.Println(m[\u0026#34;Answer\u0026#34;]) // Phần tử có key = \u0026#34;Answer\u0026#34; đã bị xóa, kết quả là 0 (zero value của int) Để kiểm tra xem một phần tử có tồn tại trong map hay không, ta sẽ lấy cùng lúc 2 kết quả khi truy xuất đến phần tử trong map. Giá trị đầu tiên giống ví dụ trên, giá trị thứ 2 sẽ là true nếu phần tử có trong map và false nếu phần tử không tồn tại (gần giống callback error trong javascript).\n// Tiếp theo ví dụ trên v, ok := m[\u0026#34;Answer\u0026#34;] fmt.Println(\u0026#34;Giá trị của phần tử là: \u0026#34;, v) // v = 0 fmt.Println(\u0026#34;Kiểm tra phần tử có tồn tại hay không: \u0026#34;, ok) // ok = false Tiếp theo: Phần 5: Methods và Interfaces.\n","permalink":"https://huydq.dev/blog/hoc-go-cap-toc-phan-4-structs-va-maps/","summary":"Các phần trước:\nPhần 1: Packages, variables và functions.\nPhần 2: Điều khiển luồng với if, else, switch và defer.\nPhần 3: Arrays và Slices.\nStructs Tương tự C, một struct trong Go là tập hợp các trường (field) do người dùng tự định nghĩa. Mỗi trường có thể có kiểu dữ liệu khác nhau, thậm chí có thể là một struct. Trong Go không có class như các ngôn ngữ hướng đối tượng, do đó chúng ta có thể dùng struct thay cho class.","title":"Học Go cấp tốc Phần 4:  Structs và Maps"},{"content":"Các phần trước:\nPhần 1: Packages, variables và functions.\nPhần 2: Điều khiển luồng với if, else, switch và defer.\nArrays Array (mảng) trong Go tương tự các ngôn ngữ khác, tuy nhiên nó có kích thước cố định (fixed size) và các phần tử bên trong phải cùng loại dữ liệu. Ví dụ:\n// Khởi tạo một mảng gồm 2 string var a [2]string  // Gán giá trị cho các phần tử trong mảng a[0] = \u0026#34;Hello\u0026#34; a[1] = \u0026#34;World\u0026#34;  // In kết quả ra console fmt.Println(a[0], a[1]) fmt.Println(a)  // Khởi tạo một mảng gồm 6 số int và gán luôn giá trị cho nó primes := [6]int{2, 3, 5, 7, 11, 13} fmt.Println(primes)  // Khởi tạo mảng nhưng không ghi rõ kích thước (thay bằng dấu ba chấm), // trình biên dịch sẽ tự hiểu dựa vào số phần tử đã khai báo numbers := [...]int{12, 78, 50} fmt.Println(numbers) Không giống đa số các ngôn ngữ khác, Array trong Go không phải là dạng tham chiếu (reference types) mà là dạng tham trị (value types). Khi gán giá trị nó cho một biến mới thì nó sẽ tạo ra một bản copy của Array cũ, và mọi thay đổi ở Array mới không ảnh hưởng gì đến Array cũ:\na := [...]int{1, 2, 3, 4, 5} b := a // b là một array mới có giá trị giống a b[0] = 9 // Thay đổi giá trị một phần tử của b  fmt.Println(\u0026#34;a is \u0026#34;, a) // In ra 1 2 3 4 5 fmt.Println(\u0026#34;b is \u0026#34;, b) // In ra 9 2 3 4 5 Slices Slice là một tham chiếu đến Array, nó mô tả một phần (hoặc toàn bộ) Array. Nó có kích thước động nên thường được sử dụng nhiều hơn Array.\nSlice có thể tạo ra từ một Array bằng cách cung cấp 2 chỉ số (low và high) xác định vị trí phần tử trong Array. Ví dụ:\n// Khởi tạo Array primes primes := [6]int{2, 3, 5, 7, 11, 13}  // Khởi tạo Slice s bằng cách cắt từ phần tử ở vị trí 1 (low) đến phần tử ở vị trí 3 (high - 1) của Array primes var s []int = primes[1:4]  // In ra giá trị của Slice s fmt.Println(s) // Giá trị của s là [3, 5, 7] Một Slice sẽ có 2 thuộc tính là length(len)và capacity(cap). Length là số phần tử chứa trong Slice, còn capacity là số phần tử chứa trong Array mà Slice tham chiếu đến (bắt đầu tính từ phần tử đầu tiên của Slice). Để lấy ra length của Slice ta dùng hàm len(), còn để lấy ra capacity thì ta dùng hàm cap(). Ví dụ:\ns := []int{2, 3, 5, 7, 11, 13}  s = s[0:0] // s = [], len(s) = 0, cap(s) = 6 s = s[0:4] // s = [2, 3, 5, 7], len(s) = 4, cap(s) = 6 s = s[2:4] // s = [5, 7], len(s) = 2, cap(s) = 4, cap được tính từ vị trí số 2 trở đi s = s[0:4] // s = [5, 7, 11, 13], len(s) = 4, cap(s) = 4 Khi tạo Slice ta có thể bỏ qua các chỉ số low và high, khi đó Go sẽ tự sử dụng giá trị mặc định: 0 cho low và length của Slice cho high. Ví dụ:\ns := []int{2, 3, 5, 7, 11, 13}  s = s[:0] // s = [0:0] s = s[:4] // s = [0:4] s = s[2:] // s = [2:len(s)] =\u0026gt; s = [2:4] s = s[:4] // s = [0:4] Ngoài việc tạo Slice như trên, chúng ta có thể tạo theo các cách sau:\n  Khai báo như một mảng nhưng không chỉ ra kích thước mảng:\nq := []int{2, 3, 5, 7, 11, 13}   Sử dụng hàm make() với công thức sau:\nfunc make([]T, len, cap) []T a := make([]int, 5) // len(a)=5 b := make([]int, 0, 5) // len(b)=0, cap(b)=5   Slice có zero value là nil (length = 0 và capacity = 0), nil tương đương với giá trị null trong các ngôn ngữ lập trình khác.\nDo Slice chỉ là tham chiếu đến Array, do đó thay đổi giá trị của Slice sẽ làm thay đổi giá trị của Array mà nó tham chiếu đến. Nếu có nhiều Slice cùng tham chiếu đến một Array thì khi thay đổi giá trị một Slice có thể làm thay đổi giá trị các Slice khác. Ví dụ:\nnumbers := [4]int{1, 2, 3, 4}  a := numbers[0:2] // a = [1, 2] b := numbers[1:3] // b = [2, 3]  b[0] = 5 // Thay đổi giá trị phần tử đầu tiên của Slice b  fmt.Println(a, b) // a = [1, 5], b = [5, 3] fmt.Println(numbers) // numbers = [1, 5, 3, 4] Append Để bổ sung thêm phần tử cho slice, ta dùng hàm append() với công thức sau:\nfunc append(s []T, vs ...T) []T Hàm này sẽ trả về một slice có chứa toàn bộ các phần tử của slice ban đầu và các phần tử mới thêm vào. Trong trường hợp slice ban đầu có sức chứa nhỏ (Array mà nó tham chiếu đến có size nhỏ), một Array mới có kích thước lớn hơn sẽ được tạo ra và slice mới sẽ tham chiếu đến Array đó.\nvar s []int  // Append có thể hoạt động với nil slice. s = append(s, 0) // s = [0]  // Append thêm một phần tử vào slice. s = append(s, 1) // s = [0, 1]  // Append thêm nhiều phần tử vào slice. s = append(s, 2, 3, 4) // s = [0, 1, 2, 3, 4] Range Range là một hình thức của vòng lặp for dùng để duyệt qua một slice hoặc map(sẽ nhắc đến ở phần sau). Mỗi một vòng lặp sẽ trả về 2 giá trị: Giá trị đầu tiên là chỉ số (vị trí) của phần tử, và giá trị thứ hai là bản sao của phần tử đó (cùng giá trị). Ví dụ:\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128} for i, v := range pow {  fmt.Printf(\u0026#34;i = %d, v = %d \\n\u0026#34;, i, v) } Trong trường hợp khi lặp chỉ sử dụng 1 trong 2 giá trị trả về thì ta sẽ bỏ qua giá trị còn lại bằng cách thay tên biến bằng ký tự gạch dưới (vì nếu không thì khi biên dịch sẽ báo lỗi biến được định nghĩa mà không sử dụng). Ví dụ:\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128} for _, v := range pow {  fmt.Printf(\u0026#34;v = %d \\n\u0026#34;, v) } Tiếp theo: Phần 4: Structs và Maps.\n","permalink":"https://huydq.dev/blog/hoc-go-cap-toc-phan-3-arrays-va-slices/","summary":"Các phần trước:\nPhần 1: Packages, variables và functions.\nPhần 2: Điều khiển luồng với if, else, switch và defer.\nArrays Array (mảng) trong Go tương tự các ngôn ngữ khác, tuy nhiên nó có kích thước cố định (fixed size) và các phần tử bên trong phải cùng loại dữ liệu. Ví dụ:\n// Khởi tạo một mảng gồm 2 string var a [2]string  // Gán giá trị cho các phần tử trong mảng a[0] = \u0026#34;Hello\u0026#34; a[1] = \u0026#34;World\u0026#34;  // In kết quả ra console fmt.","title":"Học Go cấp tốc Phần 3:  Arrays và Slices"},{"content":"Phần trước: Học Go cấp tốc Phần 1: Packages, variables và functions.\nPhần tiếp theo chúng ta sẽ cùng tìm hiểu cách điều khiển luồng (flow control) trong Go.\nVòng lặp Trong Go chỉ có 1 kiểu vòng lặp là sử dụng for. Cách dùng tương tự các ngôn ngữ khác nhưng phần khai báo biến, điều kiện lặp, \u0026hellip; không cần đặt trong cặp ngoặc tròn:\n// Tính tổng các số từ 0 - 9 sum := 0 for i := 0; i \u0026lt; 10; i++ {  sum += i } fmt.Println(sum) Vòng lặp for khi chỉ có điều kiện lặp thì hoạt động giống while trong các ngôn ngữ khác:\nsum := 0 for sum \u0026lt; 10 {  sum += 1 } fmt.Println(sum) Điều kiện Lệnh điều kiện trong Go sử dụng if, else, switch, và cũng như vòng lặp for chúng ta không cần cặp ngoặc tròn.\nVới câu lệnh if chúng ta có thể khai báo biến ngay trong câu lệnh điều kiện, và biến này sẽ chỉ hoạt động ở trong block của lệnh if hoặc else:\nimport (  \u0026#34;fmt\u0026#34;  \u0026#34;math\u0026#34; )  func pow(x, n, limit float64) float64 {  // Khai báo biến v trong lệnh điều kiện của if sẽ chỉ sử dụng được trong block if hoặc else  if v := math.Pow(x, n); v \u0026lt; limit {  return v  } else {  fmt.Printf(\u0026#34;%g \u0026gt;= %g\\n\u0026#34;, v, limit) \t}  \t// Không sử dụng được biến v ở bên ngoài, ví dụ return v sẽ báo lỗi \treturn lim } Lệnh switch tương tự các ngôn ngữ khác, tuy nhiên có một số điểm khác biệt:\n  Biểu thức trong switch không được sử dụng hằng số (constant). Không cần lệnh break trong mỗi case(mặc định các case tự break). Do đó chỉ có trường hợp thỏa mãn đầu tiên được chạy (tính từ trên xuống dưới). Ví dụ:\nswitch num := 10; {  case num \u0026lt; 50:  fmt.Printf(\u0026#34;%d \u0026lt; 50\\n\u0026#34;, num) // In ra 10 \u0026lt; 50  case num \u0026lt; 100:  fmt.Printf(\u0026#34;%d \u0026lt; 100\\n\u0026#34;, num) // Lệnh này không chạy mặc dù cũng thỏa mãn điều kiện  default:  fmt.Printf(\u0026#34;I don\u0026#39;t know\u0026#34;, num) }   Có thể sử dụng nhiều điều kiện trong một case,hoặc sử dụng từ khóa fallthrough để cho phép chạy tiếp xuống câu lệnh tiếp theo:\nnum := 10;  switch { // Tương đương với switch true  case num \u0026gt;= 0 \u0026amp;\u0026amp; num \u0026lt;= 50:  fmt.Printf(\u0026#34;%d \u0026lt; 50 \\n\u0026#34;, num) // In ra 10 \u0026lt; 50  fallthrough  case num \u0026lt; 100:  fmt.Printf(\u0026#34;%d \u0026lt; 100 \\n\u0026#34;, num) // In ra 10 \u0026lt; 100  default:  fmt.Printf(\u0026#34;I don\u0026#39;t know\u0026#34;, num) }   Trì hoãn Trì hoãn (defer) là một khái niệm khá mới trong điều khiển luồng. Nó cho phép một câu lệnh được gọi ra nhưng không thực thi ngay mà hoãn lại đến khi các lệnh xung quanh trả về kết quả. Ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  func main() {  defer fmt.Println(\u0026#34;World\u0026#34;) // Hoãn lệnh in ra chữ \u0026#34;World\u0026#34;  fmt.Println(\u0026#34;Hello\u0026#34;) // In ra chữ \u0026#34;Hello\u0026#34;  // Kết quả cuối cùng là \u0026#34;Hello World\u0026#34; } Các lệnh được gọi qua từ khóa defer sẽ được đưa vào một stack, tức là hoạt động theo cơ chế vào sau ra trước (last-in-first-out). Lệnh nào defer sau sẽ được thực thi trước, giống như xếp 1 chồng đĩa thì chiếc đĩa sau cùng (ở trên cùng) sẽ được lấy ra trước. Ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  func main() {  for i := 0; i \u0026lt; 10; i++ {  defer fmt.Println(i) // In ra giá trị của biến i  }   // Kết quả trả về ngược so với vòng lặp:  // 9 8 7 6 5 4 3 2 1 0 } Chú ý là khi gọi lệnh defer thì giá trị của biến trong câu lệnh sẽ là giá trị tại thời điểm gọi chứ không phải giá trị tại thời điểm thực thi.\nTiếp theo: Phần 3: Arrays và Slices.\n","permalink":"https://huydq.dev/blog/hoc-go-cap-toc-phan-2-dieu-khien-luong-voi-if-else-switch-va-defer/","summary":"Phần trước: Học Go cấp tốc Phần 1: Packages, variables và functions.\nPhần tiếp theo chúng ta sẽ cùng tìm hiểu cách điều khiển luồng (flow control) trong Go.\nVòng lặp Trong Go chỉ có 1 kiểu vòng lặp là sử dụng for. Cách dùng tương tự các ngôn ngữ khác nhưng phần khai báo biến, điều kiện lặp, \u0026hellip; không cần đặt trong cặp ngoặc tròn:\n// Tính tổng các số từ 0 - 9 sum := 0 for i := 0; i \u0026lt; 10; i++ {  sum += i } fmt.","title":"Học Go cấp tốc Phần 2:  Điều khiển luồng với if, else, switch và defer"},{"content":" Go(hay thường được gọi là Golang) là một ngôn ngữ lập trình mã nguồn mở được tạo ở Google vào năm 2009 bởi Robert Griesemer, Rob Pike, và Ken Thompson. Nó được ra đời nhằm mục đích phát triển các trang web nhanh hơn, dễ dàng hơn và đáp ứng được yêu cầu truy cập lớn. Về lịch sử ra đời cũng như giới thiệu chi tiết hơn các bạn có thể xem ở wikipedia 😅\n Để học Go thì chúng ta có nhiều nguồn và tài liệu khác nhau. Với những người đã biết ít nhất một ngôn ngữ lập trình thì có thể thực hành luôn theo theo Tour Golang, nó sẽ gồm các ví dụ và bài tập mẫu mô tả các chức năng cơ bản trong Go và đi kèm 1 editor online để chúng ta có thể thực hành luôn mà không cần cài đặt.\nTrong quá trình học theo Tour Golang, mình sẽ viết bài tổng kết lại một số kiến thức cơ bản, điểm khác biệt của Go so với các ngôn ngữ khác (có thể sẽ sử dụng ví dụ khác với nguyên mẫu). Nếu bạn muốn học Go và thực hành luôn trên Tour Golang thì có thể tham khảo series này (hoặc có thể đọc lướt qua để có một cái nhìn tổng quát về Go).\nPackages Mọi chương trình viết từ Go đều được tạo bởi các package và package chính dùng để chạy là main.\nĐể sử dụng các package khác thì chúng ta phải import, ví dụ muốn in 1 đoạn text ra console thì ta phải dùng package fmt:\npackage main  import \u0026#34;fmt\u0026#34;  func main() {  fmt.Println(\u0026#34;Lại là Hello World\u0026#34;) } Variables Cú pháp của Go tương tự C nhưng cũng có nhiều điểm khác, ví dụ không có dấu chấm phẩy ở cuối các câu lệnh hay kiểu dữ liệu được khai báo ở sau tên biến. Về việc tại sao Go lại khai báo kiểu dữ liệu ngược so với hầu hết các ngôn ngữ khác các bạn tự tìm hiểu tại đây Go\u0026rsquo;s Declaration Syntax.\nKhai báo biến trong Go ngoài việc cú pháp hơi dị một chút, còn đâu thì vẫn tương tự như các ngôn ngữ khác:\n// Khai báo biến message có kiểu dữ liệu string var message string  // Khai báo 3 biến c, python, java đều có kiểu dữ liệu là bool var c, python, java bool  // Khai báo 2 biến i, j có kiểu dữ liệu là int và khởi tạo luôn giá trị cho chúng var i, j int = 1, 2  // Khai báo ngắn gọn biến k và khởi tạo giá trị luôn cho nó. // Không dùng từ khóa var mà dùng dấu hai chấm, lúc này kiểu dữ liệu sẽ được ngầm định tùy theo giá trị của biến. k := 3 Các kiểu dữ liệu trong Go, ở phần mô tả của Tour of Go có liệt kê đầy đủ: Go basic types\nKhi khai báo biến mà không khởi tạo giá trị ban đầu cho nó thì biến đó sẽ có giá trị zero tùy thuộc vào kiểu dữ liệu:\n 0 cho kiểu số. false cho kiểu boolean. \u0026quot;\u0026quot; cho kiểu chuỗi.  Khi thực hiện tính toán giữa các biến với kiểu dữ liệu khác nhau sẽ cần ép kiểu (type conversions) theo công thức T(v) với T là kiểu dữ liệu (type) còn v là giá trị (value):\ni := 55 // kiểu int j := 67.8 // kiểu float64 sum := i + int(j) // Để tính tổng cần phải ép kiểu j về int (sum = 55 + 67) fmt.Println(sum) // Kết quả trả về là 122 Khai báo hằng số thì tương tự khai báo biến nhưng dùng từ khóa const và không dùng được cú pháp viết tắt :=\nconst Pi = 3.14 Functions Khai báo hàm sử dụng từ khóa func, và chú ý tham số truyền vào cũng khai báo kiểu dữ liệu sau tên tham số:\n// Hàm tính tổng, có 2 tham số truyền vào với kiểu dữ liệu int và kết quả trả về cũng là int func add(x int, y int) int {  return x + y } Khi các tham số truyền vào cùng kiểu dữ liệu thì có thể viết tắt như sau:\n// Hàm tính tổng, có 2 tham số truyền vào với kiểu dữ liệu int và kết quả trả về cũng là int func add(x, y int) int {  return x + y } Điểm đặc biệt trong Go đó là function có thể trả về nhiều kết quả, ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  // Hàm swap trả về kết quả là 2 chuỗi func swap(x, y string) (string, string) { \treturn y, x }  func main() {  // Gán kết quả của hàm swap vào 2 biến a và b  a, b := swap(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;)   // In ra giá trị của a và b  fmt.Println(a, b) } Kết quả trả về có thể đặt tên để sử dụng luôn trong hàm, ví dụ:\n// Hàm split khai báo 2 kết quả trả về là x và y có kiểu dữ liệu là int func split(sum int) (x, y int) {  x = sum * 4 / 9  y = sum - x   // return có thể để trống, function sẽ tự động trả về x và y (không khuyến khích)  return } Tiếp theo: Phần 2: Điều khiển luồng với if, else, switch và defer.\n","permalink":"https://huydq.dev/blog/hoc-go-cap-toc-phan-1-packages-variables-va-functions/","summary":"Go(hay thường được gọi là Golang) là một ngôn ngữ lập trình mã nguồn mở được tạo ở Google vào năm 2009 bởi Robert Griesemer, Rob Pike, và Ken Thompson. Nó được ra đời nhằm mục đích phát triển các trang web nhanh hơn, dễ dàng hơn và đáp ứng được yêu cầu truy cập lớn. Về lịch sử ra đời cũng như giới thiệu chi tiết hơn các bạn có thể xem ở wikipedia 😅","title":"Học Go cấp tốc Phần 1: Packages, variables và functions"},{"content":"Kong cung cấp một RESTful Admin API cho phép chúng ta thực hiện việc cấu hình và quản lý các API. Mặc định Admin API sẽ lắng nghe ở cổng 8001 và cổng 8444 cho giao thức https. Chú ý API này chỉ dùng trong nội bộ, không public ra ngoài, vì nó cho phép quản lý toàn bộ hệ thống API gateway của Kong.\nĐể dễ hình dung, bài viết này sẽ hướng dẫn tạo mới các API và bảo mật cơ bản bằng plugins sử dụng Konga (GUI cho Admin API). Tuy nhiên các bạn có thể dùng curl hay Postman để test. Tài liệu tham khảo: Danh sách các endpoint và tham số của Kong Admin API.\nSau khi cài đặt và đăng nhập vào Konga, chúng ta sẽ kết nối Konga với Kong Admin API (chú ý Active connection):\nThêm mới API Endpoint: Add API\nCác tham số cần thiết:\n name: Tên của API (sử dụng để quản lý API). Ngoài name ra cũng thể dùng id để quản lý API (do hệ thống tự tạo). hosts, uris, methods: Dùng để phân biệt giữa các API, luôn phải có ít nhất 1 trong 3 thuộc tính này. Hosts là phân biệt qua Headers của request, uris là phân biệt qua đường dẫn và methods là phân biệt qua phương thức của request. upstream_url: Đường dẫn gốc của API.    Ví dụ thêm API trỏ đến techmaster.vn qua đường dẫn /techmaster   Các API sẽ chạy qua cổng 8000, trong ví dụ này chúng ta chạy trên localhost nên sẽ truy cập vào localhost:8000. Với cấu hình như ví dụ trên thì khi chúng ta truy cập vào localhost:8000/techmaster, Kong sẽ forward sang trang techmaster.vn. Tuy nhiên đường dẫn một số file như css sẽ bị sai do đường dẫn không bắt đầu từ tên domain (đường dẫn gốc). Do đó nếu sử dụng đường dẫn để phân biệt API thì với ứng dụng web frontend nên dùng cho đường dẫn gốc là /.\nCấu hình plugins Để bảo mật API, chúng ta sẽ cấu hình thêm một số plugins của Kong. Ví dụ để Authentication chúng ta có thể dùng một số plugins như: Basic Authentication, Key Authentication, JWT, \u0026hellip; (một số plugins có nhãn Enterprise sẽ phải trả phí để sử dụng).\nPlugins có thể áp dụng cho toàn bộ API hoặc cho cụ thể từng API qua name hoặc id của chúng. Endpoint Add Plugin.\nVí dụ cấu hình plugin Basic Authentication:\nSau khi kích hoạt Plugin, để truy cập được vào API chúng ta sẽ phải qua một bước Authentication của browser: Nếu user nhập đúng Username và Password thì mới truy cập được vào API. Nếu là gửi request thì trong Headers của request phải có thuộc tính Proxy-Authorization hoặc Authorization có chứa Username và Password được mã hóa base64 theo cú pháp Username:Password.\nTạo Consumer Bước thiếp theo chúng ta phải tạo Consumer để truy cập API. Endpoint Create Consumer.\nTrong Consumer, chúng ta tạo thêm các Credentials tương ứng với các tài khoản truy cập cho Authentication:\nVậy là chúng ta đã cấu hình xong Basic Authentication cho API. Với các Plugins khác thì cũng làm tương tự.\n","permalink":"https://huydq.dev/blog/them-moi-va-bao-mat-api-trong-kong-api-gateway/","summary":"Kong cung cấp một RESTful Admin API cho phép chúng ta thực hiện việc cấu hình và quản lý các API. Mặc định Admin API sẽ lắng nghe ở cổng 8001 và cổng 8444 cho giao thức https. Chú ý API này chỉ dùng trong nội bộ, không public ra ngoài, vì nó cho phép quản lý toàn bộ hệ thống API gateway của Kong.\nĐể dễ hình dung, bài viết này sẽ hướng dẫn tạo mới các API và bảo mật cơ bản bằng plugins sử dụng Konga (GUI cho Admin API).","title":"Thêm mới và bảo mật API trong Kong API Gateway"},{"content":" ASP.NET Core là một open-source web framework mới của Microsoft. Nó cho phép phát triển và chạy ứng dụng web đa nền tảng. Giờ đây bạn có thể lập trình .NET trên cả Linux và MacOS.\n Để lập trình chúng ta có thể sử dụng Visual Studio (trên Windows) hoặc Visual Studio for Mac (trên Mac). Ngoài ra chúng ta cũng có thể dùng Visual Studio Code (VS Code) để lập trình trên cả Windows, MacOS và Linux. VS Code là một Editor hoàn toàn miễn phí và chạy rất nhẹ. Các chức năng của nó cũng khá đầy đủ và có thể cài thêm các Extension để hỗ trợ, bổ sung thêm tính năng tùy vào từng dự án.\nDưới đây là một số cấu hình, tùy chỉnh của mình cho VS Code khi lập trình ASP.NET Core.\n1. Cài đặt Extension Có nhiều Extension hỗ trợ cho việc lập trình ASP.NET Core, tuy nhiên đến thời điểm hiện tại thì có Extension C# (ms-vscode.csharp) là được dùng nhiều nhất và được khuyến cáo sử dụng.\n2. Tùy chỉnh phím tắt Việc thiết lập phím tắt sẽ giúp bạn code nhanh hơn. Chúng ta có thể sửa lại các phím tắt mặc định theo ý mình bằng cách chọn File / Preferences / Keyboard Shortcuts. Tìm đến chức năng muốn thiết lập, chọn biểu tượng Edit hoặc bấm Enter để gán phím tắt cho chức năng đó.\nNếu thiết lập sai (ví dụ bị trùng phím tắt), ta có thể khôi phục lại như cũ bằng cách bấm chuột phải vào chức năng và chọn Reset Keybinding.\n3. Cấu hình Editor VS Code cho phép chúng ta tùy chỉnh việc hiển thị, cách thức làm việc, \u0026hellip; trong phần File / Preferences / Settings. Để cấu hình chúng ta sẽ khai báo các thuộc tính và giá trị trong một file JSON. Chúng ta sẽ copy cấu hình mặc định (Default Setings) sang bên User Settings (hoặc Workspace Settings) với các giá trị mới. Với các cấu hình giống nhau thì VS Code sẽ nhận các giá trị theo mức độ ưu tiên Workspace Settings \u0026gt; User Settings \u0026gt; Default Setings.\n4. Cấu hình launch.json Đây là file cấu hình chạy Debug ứng dụng trên VS Code (nằm trong thư mục .vscode của project). Các bạn có thể tham khảo tài liệu chi tiết ở đây. Với ứng dụng ASP.NET Core thì khi bật Debug, mặc định nó sẽ mở một tab mới trên trình duyệt. Để bỏ chức năng này thì chúng ta sửa lại cấu hình launchBrowser enabled thành false:\n...  \u0026#34;launchBrowser\u0026#34;: {  \u0026#34;enabled\u0026#34;: false,  ...  } ... 5. Cấu hình task.json Task là một chức năng của VS Code cho phép chúng ta tích hợp thêm các External Tools vào trong project như MSbuild, Grunt, Gulp, \u0026hellip; và chúng ta sẽ cấu hình trong file .vscode/task.json. Tham khảo tài liệu chi tiết ở đây.\nTrong project ASP.NET Core thì cần sửa lại cấu hình của msCompile để khi compile lỗi chúng ta có thể chuyển nhanh sang đoạn code gây lỗi.\n  Khi gặp lỗi có thể bấm vào các dòng thông báo để bật nhanh đoạn code bị lỗi   Mặc định msCompile dùng kiểu đường dẫn đầy đủ, nên có thể sẽ gặp lỗi không mở được file:\n  Không mở được file do hiểu nhầm đường dẫn   Sửa lại cấu hình trong file task.json sang kiểu đường dẫn tương đối (relative):\n...  \u0026#34;problemMatcher\u0026#34;: {  \u0026#34;base\u0026#34;: \u0026#34;$msCompile\u0026#34;,  \u0026#34;fileLocation\u0026#34;: [\u0026#34;relative\u0026#34;, \u0026#34;${workspaceRoot}\u0026#34;]  } ... Trên đây là một số kinh nghiệm của mình khi thiết lập môi trường làm việc ASP.NET Core với Visual Studio Code. Các bạn có thể tham khảo để setup cho mình một môi trường phát triển tiện lợi và phù hợp nhất.\nHappy Coding 😁 .\n","permalink":"https://huydq.dev/blog/tuy-chinh-visual-studio-code-khi-lap-trinh-aspnet-core/","summary":"ASP.NET Core là một open-source web framework mới của Microsoft. Nó cho phép phát triển và chạy ứng dụng web đa nền tảng. Giờ đây bạn có thể lập trình .NET trên cả Linux và MacOS.\n Để lập trình chúng ta có thể sử dụng Visual Studio (trên Windows) hoặc Visual Studio for Mac (trên Mac). Ngoài ra chúng ta cũng có thể dùng Visual Studio Code (VS Code) để lập trình trên cả Windows, MacOS và Linux.","title":"Tùy chỉnh Visual Studio Code khi lập trình ASP.NET Core"},{"content":"Thông thường khi làm dự án với Entity Framework, chúng ta hay dùng cơ sở dữ liệu (CSDL) MS SQL Server. Tuy nhiên tùy theo yêu cầu công việc, bạn có thể sẽ phải làm việc với các cơ sở dữ liệu khác. Bài viết này mình sẽ chia sẻ 1 số kinh nghiệm của bản thân khi phải làm việc với CSDL Oracle (cụ thể là Oracle phiên bản 11g).\nCài đặt provider Để cài đặt provider thì chúng ta có thể cài đặt qua NuGet hoặc download trên trang chủ của Oracle. Nhưng do tính chất công việc cần bảo mật, mình không được sử dụng internet nên chọn cách sử dụng bộ cài ODAC trên Oracle: http://www.oracle.com/technetwork/topics/dotnet/utilsoft-086879.html. Các bạn có thể sử dụng phiên bản ODAC 11.2 trở lên, ở đây mình dùng hẳn luôn bản mới ODAC 12c Release 4 vì nó có tính tương thích ngược.\nĐể cài ODAC thì các bạn chỉ cần giải nén file tải về và chạy tệp setup.exe (Oracle Universal Installer), nhưng sẽ có 1 số lưu ý sau:\n  Nếu trên máy đã có ODAC bản cũ thì cần gỡ ra trước khi cài mới bằng cách sử dụng Universal Installer (Windows Start Menu \u0026ndash;\u0026gt; All Programs \u0026ndash;\u0026gt; Oracle - \u0026ndash;\u0026gt; Oracle Installation Products \u0026ndash;\u0026gt; Universal Installer).\n  Khi cài đến phần chọn thư mục cài đặt (Specify Installation Location) thì cần chú ý trong đường dẫn không được phép chứa các ký tự đặc biệt (ví dụ như dấu cách). Có thể lúc cài thì vẫn cài được nhưng sau đó sẽ bị lỗi (mình đã bị dính lỗi này khi sử dụng Windows Built-in Account có username chứa dấu cách).\n  Một số khác biệt khi sử dụng CSDL Oracle   Trong Oracle không dùng khái niệm database như các CSDL khác mà sử dụng khái niệm Schemas, và Schemas tương ứng với Users. Tức là ở trong MS SQL Server chúng ta tạo mới một database thì ở đây chúng ta tạo mới một user (schema). Ví dụ chúng ta cần tạo một ứng dụng quản lý sinh viên thì thay vì tạo database student, chúng ta tạo mới một user tên là student.\n  Tất cả tên bảng trong schema không được vượt quá 30 ký tự.\n  Lỗi ORA-01918: user \u0026ldquo;dbo\u0026rdquo; does not exist khi sử dụng EF Migration, đó là do Oracle hiểu nhầm dbo.table_name là bảng table_name trong schema dbo. Sửa bằng cách đổi lại schema trong class DbContext bằng cách ghi đè phương thức OnModelCreating, ví dụ schema của mình là ROBIN (chú ý viết hoa):\n  public class ApplicationDbContext : IdentityDbContext {  public ApplicationDbContext() : base(\u0026#34;ROBIN\u0026#34;, throwIfV1Schema: false)  {  }   public static ApplicationDbContext Create()  {  return new ApplicationDbContext();  }   protected override void OnModelCreating(DbModelBuilder modelBuilder)  {  base.OnModelCreating(modelBuilder);  modelBuilder.HasDefaultSchema(\u0026#34;ROBIN\u0026#34;);  } } Hy vọng một số kinh nghiệm trên đây sẽ giúp những ai mới làm việc với Oracle giảm bớt thời gian tìm hiểu cài đặt hay fix những bug kể trên.\n","permalink":"https://huydq.dev/blog/su-dung-co-so-du-lieu-oracle-voi-entity-framework/","summary":"Thông thường khi làm dự án với Entity Framework, chúng ta hay dùng cơ sở dữ liệu (CSDL) MS SQL Server. Tuy nhiên tùy theo yêu cầu công việc, bạn có thể sẽ phải làm việc với các cơ sở dữ liệu khác. Bài viết này mình sẽ chia sẻ 1 số kinh nghiệm của bản thân khi phải làm việc với CSDL Oracle (cụ thể là Oracle phiên bản 11g).","title":"Sử dụng cơ sở dữ liệu Oracle với Entity Framework"},{"content":"Bài trước mình đã hướng dẫn cách tạo chứng chỉ SSL miễn phí với Let\u0026rsquo;s Encrypt. Tiếp theo mình sẽ hướng dẫn các bạn cách tạo chứng chỉ SSL qua dịch vụ của Namecheap (mất phí nhé 😂)\nĐăng ký dịch vụ của Namecheap\nĐầu tiên chúng ta sẽ cần đăng ký tài khoản tại Namecheap và chọn 1 loại chứng chỉ phù hợp https://www.namecheap.com/security/ssl-certificates.aspx\nSau khi đã thanh toán, truy cập vào Dashboard để active dịch vụ\n  Di chuột đến phần tên user góc trên bên phải để truy cập Dashboard     Trên menu chọn phần Product List / SSL Certificates     Chọn ACTIVATE để kích hoạt dịch vụ   Tiếp theo để kích hoạt dịch vụ chúng ta sẽ cần điền một CSR (Certificate Signing Request), đó là 1 đoạn code mã hóa thông tin về công ty và tên miền. Để tạo mã CSR, chúng ta cần truy cập vào server và gõ lệnh sau:\n$ openssl req -new -newkey rsa:2048 -nodes -keyout server.key -out server.csr Khi trên server có nhiều website thì chúng ta nên thay server.key và server.csr bằng tên miền để tránh nhầm lẫn, ví dụ nctest.info.key và nctest.info.csr hoặc lưu vào 1 thư mục riêng ví dụ /etc/ssl/nctest.info\nKhi thực hiện lệnh, chúng ta sẽ phải điền 1 số thông tin của công ty và domain ví dụ như sau:\nCountry Name (2 letter code) [AU]: VN State or Province Name (full name) [Some-State]: Hanoi Locality Name (eg, city) []: Hanoi Organization Name (eg, company) [Internet Widgits Pty Ltd]: NCTEST Ltd Organizational Unit Name (eg, section) []: Training Common Name (e.g. server FQDN or YOUR name) []: nctest.info Email Address []: administrator@nctest.info Kết quả chúng ta sẽ có 2 file là server.key (Private Key) và server.csr (mã CSR). File server.key sẽ dùng để chứng thực nên cần lưu lại cẩn thận để dùng đến sau này. File server.csr sẽ dùng để gửi dữ liệu lên namecheap, chúng ta dùng lệnh sau để đọc nội dung file và copy để điền vào form đăng ký cat server.csr\n  Copy mã CSR và điền vào form, chọn Web-Server Nginx sau đó Submit   Phần nào không điền được thì có thể để \u0026lsquo;NA\u0026rsquo; và chú ý chỉ sử dụng ký tự alphabet, tiếng Anh không dấu.\nChọn phương thức xác thực\nCó 3 loại phương thức xác thực là Email, HTTP-based và DNS-based. Ở đây mình sẽ hướng dẫn theo cách đầu tiên là xác thực qua Email, 2 cách còn lại các bạn xem hướng dẫn tiếng Anh tại website.\n  Ví dụ xác thực qua Email       Xác nhận gửi email   Xong, tiếp theo chúng ta chờ Namecheap gửi email xác thực và chứng chỉ SSL qua email đăng ký (ví dụ admin@nctest.info).\nChứng chỉ SSL sẽ được đính kèm theo email, tải về và upload lên server và giải nén chúng ta sẽ được 2 file dạng như sau nctest.info.crt và nctest.info.ca-bundle, nối 2 file lại bằng lệnh cat (nếu có nhiều file hơn thì cũng nối lại thành 1 file tương tự):\n$ cat nctest.info.crt nctest.info.ca-bundle \u0026gt;\u0026gt; cert_chain.crt Chúng ta sẽ sử dụng file đã nối là cert_chain.crt và file Private key tạo lúc ban đầu là server.key để cài đặt SSL.\nCấu hình Nginx\nSửa file cấu hình cho domain, nếu chưa lắng nghe ở cổng 443 thì bổ sung thêm, và trỏ đường dẫn vào 2 file cert_chain.crt và server.key:\nserver { listen 443; ssl on; ssl_certificate /etc/ssl/nctest.info/cert_chain.crt; ssl_certificate_key /etc/ssl/nctest.info/server.key; server_name nctest.info; access_log /var/log/nginx/nginx.vhost.access.log; error_log /var/log/nginx/nginx.vhost.error.log; location / { root /var/www/; index index.html; } } Hoặc tham khảo file cấu hình ở bài hướng dẫn trước. Sau khi sửa xong nhớ khởi động lại Nginx và hưởng thụ thành quả 😊\n","permalink":"https://huydq.dev/blog/cai-dat-chung-chi-ssl-cua-namecheap-voi-nginx/","summary":"Bài trước mình đã hướng dẫn cách tạo chứng chỉ SSL miễn phí với Let\u0026rsquo;s Encrypt. Tiếp theo mình sẽ hướng dẫn các bạn cách tạo chứng chỉ SSL qua dịch vụ của Namecheap (mất phí nhé 😂)\nĐăng ký dịch vụ của Namecheap\nĐầu tiên chúng ta sẽ cần đăng ký tài khoản tại Namecheap và chọn 1 loại chứng chỉ phù hợp https://www.namecheap.com/security/ssl-certificates.aspx\nSau khi đã thanh toán, truy cập vào Dashboard để active dịch vụ","title":"Cài đặt chứng chỉ SSL của Namecheap với Nginx"},{"content":"Hiện nay hầu hết các trang web đều đã hỗ trợ SSL (Secure Socket Layer). Nó mã hóa dữ liệu truyền đi giữa máy chủ web và trình duyệt và làm tăng tính bảo mật cho website. Ngoài ra, việc sử dụng SSL certificate (chứng chỉ SSL) là cần thiết bởi hiện tại Google đã ưu tiên xếp hạng website dựa theo giao thức https (HTTP + SSL), những website mà chỉ sử dụng giao thức http sẽ bị coi là \u0026ldquo;unsafe\u0026rdquo; (không an toàn).\nCó nhiều loại chứng chỉ SSL cung cấp các mức độ bảo mật khác nhau. Ví dụ chúng ta có thể mua một Chứng chỉ SSL tại Namecheap với các mức giá khác nhau tùy từng loại. Tuy nhiên trong bài viết này chúng ta sẽ chỉ nói đến loại cơ bản nhất và làm thế nào để có được nó một cách miễn phí 😁\nMột số cách để có chứng chỉ SSL miễn phí\n  Sử dụng Cloudflare: Đây là một website cung cấp dịch vụ tăng tốc và bảo mật website, họ có cung cấp chứng chỉ SSL ở gói Free. Việc đăng ký rất dễ dàng nên mình sẽ không hướng dẫn ở đây. Chú ý là với website chỉ phục vụ người dùng tại Việt Nam thì chạy qua Cloudflare có thể sẽ chậm hơn 1 chút do sử dụng CDN server ngoài Việt Nam.\n  Sử dụng Let\u0026rsquo;s Encrypt: Sử dụng dịch vụ này chúng ta sẽ tự tạo SSL certificate cho riêng mình và hoàn toàn miễn phí.\n  Cách tạo SSL certificate với Let\u0026rsquo;s Encrypt\nGiả sử chúng ta đang sử dụng 1 server Ubuntu với tài khoản truy cập có quyền sudo và sử dụng web server là Nginx.\nBước 1: Cài đặt gói letsencrypt (với bản mới sẽ đổi tên là certbot và dùng lệnh certbot thay cho letsencrypt)\n$ sudo apt-get update $ sudo apt-get install letsencrypt hoặc làm theo hướng dẫn tại trang chủ https://certbot.eff.org/\nBước 2: Tạo SSL certificate\n Thêm đoạn cấu hình sau vào block server của file cấu hình cho website (thường nằm trong /etc/nginx/sites-enabled hoặc /etc/nginx/conf.d) để cho phép truy cập vào thư mục ẩn (.well-known) phục vụ cho việc xác thực:  ... location ~ /.well-known { allow all; } ...  Kiểm tra lại cấu hình xem có sai cú pháp chỗ nào không bằng lệnh:  $ nginx -t  Nếu có báo lỗi thì sửa theo hướng dẫn, sau đó khởi động lại Nginx:  $ sudo systemctl restart nginx  Tạo SSL certificate (thay example.com bằng tên miền của bạn và /var/www/example.com là đường dẫn đến thư mục gốc của website):  $ sudo letsencrypt certonly -a webroot --webroot-path=/var/www/example.com -d example.com -d www.example.com  Nếu thành công output sẽ trông như sau:  IMPORTANT NOTES: - If you lose your account credentials, you can recover through e-mails sent to sammy@digitalocean.com - Congratulations! Your certificate and chain have been saved at /etc/letsencrypt/live/example.com/fullchain.pem. Your cert will expire on 2016-03-15. To obtain a new version of the certificate in the future, simply run Let\u0026#39;s Encrypt again. ... Bước 3: Cấu hình SSL cho website\n Để tăng tính bảo mật, tạo Strong Diffie-Hellman Group:  $ sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048  Tạo 1 snippet cho Nginx để có thể tái sử dụng được khi muốn cấu hình cho nhiều website:  $ sudo nano /etc/nginx/snippets/ssl-params.conf Nội dung file như sau:\nssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ssl_ciphers \u0026#34;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\u0026#34;; ssl_ecdh_curve secp384r1; ssl_session_cache shared:SSL:10m; ssl_stapling on; ssl_stapling_verify on; ssl_dhparam /etc/ssl/certs/dhparam.pem; resolver 8.8.8.8 8.8.4.4 valid=300s; resolver_timeout 5s; add_header Strict-Transport-Security \u0026#34;max-age=63072000; includeSubdomains\u0026#34;; add_header X-Frame-Options DENY; add_header X-Content-Type-Options nosniff; Tham khảo cấu hình SSL bảo mật tại https://cipherli.st/ và https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html\n Sửa file cấu hình cho website:  Tạo redirect 301 cho block server listen 80 (http) nếu bạn chỉ muốn support https (khi người dùng truy cập với giao thức http sẽ tự động chuyển thành https)\nserver { listen 80; server_name example.com www.example.com; return 301 https://$server_name$request_uri; } Tạo thêm 1 block server listen 443 (https)\nserver { listen 443 ssl http2; server_name example.com www.example.com; ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem; include snippets/ssl-params.conf; root /var/www/example.com; location ~ /.well-known { allow all; } } Chú ý thay toàn bộ example.com bằng domain của mình và đường dẫn root /var/www/example.com giống bước tạo SSL certificate.\n Sau khi cấu hình xong thì khởi động lại Nginx:  $ sudo systemctl restart nginx  Truy cập thử website để xem thành quả hoặc kiểm tra bằng trang sau https://www.ssllabs.com/ssltest/analyze.html  Gia hạn SSL certificate\n SSL tạo theo cách này sẽ hết hạn sau 90 ngày và chúng ta sẽ phải gia hạn bằng lệnh sau:  $ sudo letsencrypt renew Để tự động hóa việc này chúng ta có thể cấu hình cronjob để tự động gia hạn chứng chỉ.\n Ví dụ cấu hình cronjob để tự động gia hạn mỗi 60 ngày:  $ sudo crontab -e Thêm vào dòng sau (đặt lịch cứ mỗi 2 tháng tự động chạy lệnh renew vào lúc 0h30):\n30 0 1 */2 * /usr/bin/letsencrypt renew \u0026amp;\u0026amp; /bin/systemctl reload nginx Xong, vậy là website của chúng ta đã có thể truy cập qua giao thức https và không lo bị hết hạn 👍.\n","permalink":"https://huydq.dev/blog/chung-chi-ssl-mien-phi-voi-lets-encrypt/","summary":"Hiện nay hầu hết các trang web đều đã hỗ trợ SSL (Secure Socket Layer). Nó mã hóa dữ liệu truyền đi giữa máy chủ web và trình duyệt và làm tăng tính bảo mật cho website. Ngoài ra, việc sử dụng SSL certificate (chứng chỉ SSL) là cần thiết bởi hiện tại Google đã ưu tiên xếp hạng website dựa theo giao thức https (HTTP + SSL), những website mà chỉ sử dụng giao thức http sẽ bị coi là \u0026ldquo;unsafe\u0026rdquo; (không an toàn).","title":"Chứng chỉ SSL miễn phí với Let's Encrypt"},{"content":"Ở bài trước mình có hướng dẫn cài đặt Gitlab trên Private Server, tuy nhiên cách cài này là cài trực tiếp lên server, có thể sẽ xung đột với các gói phần mềm có sẵn như: Redis, Nginx, \u0026hellip; Do đó bài này chúng ta sẽ thử cài Gitlab qua Docker - một công nghệ đang rất hot trong thời điểm hiện tại.\nViệc đầu tiên chúng ta phải làm đó là cài đặt Docker, các bạn tham khảo tại đây, hướng dẫn này rất chi tiết rồi mình sẽ không nhắc lại nữa.\nSau khi cài xong Docker, chúng ta chỉ việc bật terminal lên và gõ\n$ docker run -d --name local-gitlab --restart always -p 80:80 gitlab/gitlab-ce Giải thích 1 chút về câu lệnh trên:\n docker run -d: Khởi tạo và chạy 1 Container cho Gitlab dưới dạng Detached mode (có thể hình dung như 1 máy ảo, trong máy ảo đó có Gitlab) \u0026ndash;name local-gitlab: Đặt tên cho Container là local-gitlab, sau này chúng ta sẽ tương tác với Container qua tên này. \u0026ndash;restart always: Luôn luôn khởi động lại Container khi bị thoát (khi server reboot hay restart docker service) -p 80:80: Publish port 80 từ trong Container ra ngoài host để chúng ta có thể truy cập vào gitlab qua host, chúng ta cũng có thể publish ra 1 cổng khác ví dụ -p 8080:80, nếu là trên localhost thì truy cập vào gitlab như sau http://localhost:8080 gitlab/gitlab-ce: Tên của một Image trên https://hub.docker.com (cái này tương tự như Github nhưng thay vì chứa source code thì nó chứa các Image - các bản đóng gói do người khác upload lên). Chúng ta cũng có thể dùng một Image khác bằng cách search ở trên Docker hub (nên chọn Image có STARS cao và nhiều lượt PULL)  Sau khi câu lệnh chạy xong là việc cài Gitlab cũng đã hoàn tất, tuy nhiên chúng ta sẽ phải chờ thêm một vài phút để Gitlab hoàn thiện việc cấu hình. Nếu nóng lòng truy cập ngay có thể gặp lỗi như sau:\n  Nếu gặp lỗi này chỉ cần chờ 1 lúc rồi Refresh trang là được 😬   Vậy là với Docker, chúng ta có thể cài Gitlab chỉ trong 1 nốt nhạc. Còn nếu bạn muốn cấu hình cho Gitlab thì có thể dùng lệnh docker exec, ví dụ muốn sửa file cấu hình của gitlab thì chúng ta gõ lệnh sau:\n$ docker exec -it local-gitlab vim /etc/gitlab/gitlab.rb lệnh trên sẽ bật file /etc/gitlab/gitlab.rb​ trong Container gitlab bằng vim (nếu không thích dùng vim thì thay bằng nano cũng được)\nSau khi cấu hình xong thì phải restart lại Container bằng lệnh:\n$ docker restart local-gitlab Tham khảo thêm về các câu lệnh của Docker tại đây\n","permalink":"https://huydq.dev/blog/cai-dat-gitlab-bang-docker/","summary":"Ở bài trước mình có hướng dẫn cài đặt Gitlab trên Private Server, tuy nhiên cách cài này là cài trực tiếp lên server, có thể sẽ xung đột với các gói phần mềm có sẵn như: Redis, Nginx, \u0026hellip; Do đó bài này chúng ta sẽ thử cài Gitlab qua Docker - một công nghệ đang rất hot trong thời điểm hiện tại.\nViệc đầu tiên chúng ta phải làm đó là cài đặt Docker, các bạn tham khảo tại đây, hướng dẫn này rất chi tiết rồi mình sẽ không nhắc lại nữa.","title":"Cài đặt Gitlab bằng Docker"},{"content":"Gitlab là một công cụ để quản lý source code rất nổi tiếng hiện nay. Nó cho phép chúng ta tạo và quản lý các Git source repository tương tự nhu trên Github, tuy nhiên nó cho phép chúng ta tạo không giới hạn các private repository và nhiều chức năng thú vị khác như: code reviews, issue tracking, activity feeds, wikis, \u0026hellip;\nChúng ta có thể sử dụng gitlab bằng cách truy cập trang https://gitlab.com hoặc cài gitlab lên 1 server riêng. Có 2 cách để cài gitlab lên private server đó là: Cài từ source git và cài theo Omnibus package. Cài theo cách thứ 2 thì sẽ đơn giản hơn rất nhiều, chúng ta chỉ cần vào mục download, sau đó chọn server cần cài đặt và làm theo các bước hướng dẫn bên dưới.\n  Ví dụ cài Gitlab lên server Debian 8   Tóm tắt các lệnh cài đặt trên server Debian 8\n$ sudo apt-get install curl openssh-server ca-certificates postfix $ curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash $ sudo apt-get install gitlab-ce $ sudo gitlab-ctl reconfigure Sau khi cài đặt xong chúng ta có thể dùng gitlab-ctl để quản lý service:\n# Kiểm tra trạng thái $ sudo gitlab-ctl status # Bật gitlab $ sudo gitlab-ctl start # Tắt gitlab $ sudo gitlab-ctl stop # Khởi động lại gitlab $ sudo gitlab-ctl restart Chú ý\n  Gitlab Omnibus bao gồm nhiều gói package bên trong như: Nginx, Postgresql, Redis, Sidekiq, Unicorn, .. nên dung lượng khá nặng\n  Nếu trên server đang sử dụng Nginx làm web server thì có thể bị trùng cổng. Chúng ta có thể disable gói Nginx trong Gitlab Omnibus đi để dùng Nginx có sẵn:\n  Bật file /etc/gitlab/gitlab.rb và sửa các cấu hình sau:\nnginx[\u0026#39;enable\u0026#39;] = false web_server[\u0026#39;external_users\u0026#39;] = [\u0026#39;www-data\u0026#39;]```   Cập nhật lại cấu hình của Gitlab\n$ gitlab-ctl reconfigure   Cấu hình lại Nginx cho Gitlab, có thể tham khảo file cấu hình mẫu tại đây\n  Cấu hình gửi email SMTP, có thể tham khảo tại đây\n  Tham khảo document của Gitlab Omnibus: https://docs.gitlab.com/omnibus/​\n","permalink":"https://huydq.dev/blog/huong-dan-cai-dat-gitlab-tren-private-server/","summary":"Gitlab là một công cụ để quản lý source code rất nổi tiếng hiện nay. Nó cho phép chúng ta tạo và quản lý các Git source repository tương tự nhu trên Github, tuy nhiên nó cho phép chúng ta tạo không giới hạn các private repository và nhiều chức năng thú vị khác như: code reviews, issue tracking, activity feeds, wikis, \u0026hellip;\nChúng ta có thể sử dụng gitlab bằng cách truy cập trang https://gitlab.","title":"Hướng dẫn cài đặt Gitlab trên Private Server"},{"content":"Khi sử dụng thẻ img để chèn ảnh vào trang web, có 1 hiện tượng khá thú vị mà không phải ai cũng biết hoặc để ý đến. Đó là nếu bọc thẻ img bởi 1 thẻ div (hoặc bất kỳ 1 thẻ nào khác) thì sẽ xuất hiện 1 khoảng trắng nhỏ ở bên dưới ảnh.\nNếu chúng ta thiết lập padding cho thẻ div thì do khoảng trắng này mà khoảng cách phần bên dưới vẫn lớn hơn phần bên trên. Vậy khoảng trắng này từ đâu mà có?\nĐể hiểu rõ về vấn đề này, chúng ta phải nắm rõ về HTML CSS, đặc biệt là khái niệm về Inline element và Block element.\nMặc định thẻ img trong HTML là một Inline element, tức là nó được coi như là text. Do đó nó sẽ được browser xử lý như với text thông thường. Đến đây ta lại phải biết một chút về text, một số khái niệm về text trong kỹ thuật in ấn:\n Trên cùng 1 dòng, các chữ cái sẽ nằm trên một đường thẳng gọi là baseline(đó cũng là giá trị mặc định của thuộc tính vertical-align trong CSS) Một số chữ cái, ký tự đặc biệt sẽ có 1 phần nằm dưới baseline ví dụ như y, j, p, g, \u0026hellip; và phần nằm dưới đó gọi là descenders(tương tự, có 1 phần nằm trên text gọi là ascenders)   Do đó trình duyệt sẽ tạo ra 1 khoảng trắng dành cho phần descenders của text, nếu chúng ta viết thêm 1 vài ký tự có descenders vào bên cạnh ảnh và tăng font-size của chúng lên, ta sẽ thấy rõ tại sao lại có khoảng trắng nhỏ bên dưới ảnh.\nVậy là chúng ta đã khám phá được khoảng trắng bí ẩn bên dưới thẻ img. Và để xử lý khoảng trắng đó ta có thể dùng các cách sau:\n Dùng thuộc tính vertical-align cho thẻ img với giá trị là middle. Dùng thuộc tính line-height cho thẻ div với giá trị là 0. Chuyển img thành Block element với thuộc tính display.  ","permalink":"https://huydq.dev/blog/khoang-trang-bi-an-ben-duoi-the-img/","summary":"Khi sử dụng thẻ img để chèn ảnh vào trang web, có 1 hiện tượng khá thú vị mà không phải ai cũng biết hoặc để ý đến. Đó là nếu bọc thẻ img bởi 1 thẻ div (hoặc bất kỳ 1 thẻ nào khác) thì sẽ xuất hiện 1 khoảng trắng nhỏ ở bên dưới ảnh.\nNếu chúng ta thiết lập padding cho thẻ div thì do khoảng trắng này mà khoảng cách phần bên dưới vẫn lớn hơn phần bên trên.","title":"Khoảng trắng bí ẩn bên dưới thẻ Img"},{"content":"\u0026hellip; tiếp theo 29 câu lệnh Linux bạn nên biết phần 1\n17. help \u0026ndash;help xem thông tin trợ giúp và các tùy chỉnh của câu lệnh.\nCó thể viết tắt là -h\n18. whatis – What is this command whatis hiển thị mô tả về câu lệnh.\n19. man – Manual man ​ hiển thị trang hướng dẫn cho câu lệnh.\n20. exit exit ​ thoát khỏi phiên làm việc. Tương tự như việc thoát khỏi một ứng dụng trên giao diện người dùng.\n21. ping ping \u0026lt;địa chỉ host\u0026gt; ​ ping một host từ xa (server) bằng cách gửi các gói tin đến host đó. Nó thường dùng để kiểm tra kết nối mạng đến server.\nTham khảo các khóa học lập trình online, onlab, và thực tập lập trình tại TechMaster\n22. who – Who Is logged in who ​ hiển thị danh sách các tài khoản đang đăng nhập vào hệ thống.\n23. su – Switch User su ​ chuyển sang đăng nhập bằng một tài khoản khác. Tài khoản root có thể chuyển sang đăng nhập bằng các tài khoản khác mà không cần nhập mật khẩu.\n24. uname uname ​ hiển thị ra một số thông tin hệ thống như tên kernel, tên host, bộ xử lý, \u0026hellip;\nBạn có thể dùng lệnh uname -a ​ để hiển thị tất cả thông tin.\n25. free – Free memory free ​ xem thông tin về bộ nhớ: bộ nhớ đã sử dụng, bộ nhớ còn trống trên hệ thống\nBạn có thể dùng lệnh free -m ​ để xem bộ nhớ với đơn vị KBs hoặc free -g ​ để xem với đơn vị GBs\n26. df – Disk space Free df ​ xem thông tin về dung lượng đĩa cứng (đã sử dụng, còn trống, \u0026hellip;) và các thiết bị lưu trữ khác.\nBạn có thể dùng lệnh df -h ​ để xem thông tin dưới dạng human readable (hiển thị với đơn vị KBs, GBs cho dễ đọc).\n27. ps – Processes ps ​ hiển thị thông tin về các tiến trình đang chạy.\n28. top – Top processes top ​ hiển thị thông tin về các tiến trình đang chạy, sắp xếp theo hiệu suất CPU.\nBạn cũng có thể dùng lệnh top -u ​ để xem thông tin các tiến trình đang chạy của tài khoản đó.\n29. shutdown shutdown ​ lệnh tắt máy tính. Có thể dùng shutdown -r để khởi động lại máy tính.\nNguồn: http://www.hongkiat.com/blog/basic-linux-commands/\n","permalink":"https://huydq.dev/blog/29-cau-lenh-linux-ban-nen-biet-phan-2/","summary":"\u0026hellip; tiếp theo 29 câu lệnh Linux bạn nên biết phần 1\n17. help \u0026ndash;help xem thông tin trợ giúp và các tùy chỉnh của câu lệnh.\nCó thể viết tắt là -h\n18. whatis – What is this command whatis hiển thị mô tả về câu lệnh.\n19. man – Manual man ​ hiển thị trang hướng dẫn cho câu lệnh.\n20. exit exit ​ thoát khỏi phiên làm việc.","title":"29 câu lệnh Linux bạn nên biết - Phần 2"},{"content":"Các bản phân phối Linux đều có hỗ trợ giao diện người dùng để tương tác với máy tính. Tuy nhiên trong một số trường hợp sử dụng giao diện command line để điều khiển máy tính sẽ nhanh hơn và đơn giản hơn.\nTrong giao diện command line, các câu lệnh (command) dùng để ra chỉ thị cho máy tính thực hiện một tác vụ nào đó. Bạn có thể sử dụng câu lệnh để tắt máy tính, xem danh sách các file trong thư mục, sao chép file, di chuyển và xóa file, \u0026hellip;\nDưới đây tôi sẽ liệt kê các câu lệnh Linux cơ bản thường gặp để các bạn mới làm quen với Linux hoặc các quản trị viên Linux có thể dễ dàng học tập, tra cứu.\n1. ls - List ls liệt kê nội dung (file và thư mục) trong thư mục hiện hành. Nó cũng tương tự với việc bạn mở một thư mục và xem nội dung trong đó trên giao diện người dùng.\n2. mkdir - Make Directory mkdir tạo một thư mục mới. Nó cũng tương tự với việc bạn chọn new/create directory để tạo một thư mục mới trên giao diện người dùng.\n3. pwd - Print Working Directory pwd in ra đường dẫn đầy đủ đến thư mục hiện hành.\n4. cd - Change Directory cd chuyển một thư mục thành thư mục hiện hành cho phiên làm việc hiện tại. Nó cũng tương tự với việc bạn mở một thư mục và thao tác với các file và thư mục bên trong đó trên giao diện người dùng.\n5. rmdir - Remove Directory rmdir xóa một thư mục.\n6. rm - Remove rm xóa file. Bạn cũng có thể sử dụng rm -r để xóa thư mục và toàn bộ dữ liệu trong thư mục đó.\n7. cp - Copy cp sao chép file từ vị trí nguồn đến vị trí đích.\nBạn cũng có thể sử dụng cp -r để sao chép thư mục và toàn bộ dữ liệu bên trong.\n8. mv - Move mv \u0026lt;đích\u0026gt; di chuyển một file hoặc thư mục từ vị trí này sang vị trí khác. Lệnh này cũng dùng để đổi tên file hoặc thư mục nếu như và \u0026lt;đích\u0026gt; là cùng một thư mục.\n9. cat – concatenate and print files cat đọc và in ra nội dung của file ra màn hình.\n10. tail – print TAIL tail đọc và in ra nội dung 10 dòng cuối cùng của file (mặc định).\nBạn có thể sử dụng tail -n N để chỉ định in N dòng ra màn hình.\n11. less – print LESS less in ra nội dung của một file theo từng trang trong trường hợp nội dung của file quá lớn và phải đọc theo trang. Bạn có thể dùng Ctrl+F để chuyển trang tiếp theo và Ctrl+B để chuyển về trang trước.\n12. grep grep tìm kiếm nội dung của file theo chuỗi cung cấp.\nBạn có thể dùng grep -i để tìm kiếm không phân biệt hoa thường hoặc grep -r để tìm kiếm trong toàn thư mục\n13. find find -name tìm kiếm file trong theo .\nBạn cũng có thể dùng find -iname để tìm kiếm không phân biệt hoa thường.\n14. tar tar -cvf tạo file nén (.tar) từ các file có sẵn.\ntar -tvf xem nội dung file nén (.tar).\ntar -xvf giải nén (file .tar).\n15. gzip gzip tạo file nén (.gz). Sử dụng gzip -d để giải nén (file .gz).\n16. unzip unzip giải nén một file nén (.zip). Sử dụng unzip -l để xem nội dung file zip mà không cần giải nén.\nPhần tiếp theo: 29 câu lệnh Linux bạn nên biết - Phần 2\n","permalink":"https://huydq.dev/blog/29-cau-lenh-linux-ban-nen-biet-phan-1/","summary":"Các bản phân phối Linux đều có hỗ trợ giao diện người dùng để tương tác với máy tính. Tuy nhiên trong một số trường hợp sử dụng giao diện command line để điều khiển máy tính sẽ nhanh hơn và đơn giản hơn.\nTrong giao diện command line, các câu lệnh (command) dùng để ra chỉ thị cho máy tính thực hiện một tác vụ nào đó. Bạn có thể sử dụng câu lệnh để tắt máy tính, xem danh sách các file trong thư mục, sao chép file, di chuyển và xóa file, \u0026hellip;","title":"29 câu lệnh Linux bạn nên biết - Phần 1"},{"content":"Hi there 👋\nCảm ơn bạn đã ghé thăm blog của mình, một blog về công nghệ (chủ yếu là lập trình), nhưng cũng có thể có nhiều bài viết linh tinh nhảm nhí tùy hứng của tác giả.\nHy vọng các bài viết ở đây sẽ giúp phần nào cho công việc của các bạn (nếu bạn là lập trình viên), hoặc ít nhất nó cũng giúp bạn giải trí sau những giờ làm việc căng thẳng 😎.\n","permalink":"https://huydq.dev/about/","summary":"Hi there 👋\nCảm ơn bạn đã ghé thăm blog của mình, một blog về công nghệ (chủ yếu là lập trình), nhưng cũng có thể có nhiều bài viết linh tinh nhảm nhí tùy hứng của tác giả.\nHy vọng các bài viết ở đây sẽ giúp phần nào cho công việc của các bạn (nếu bạn là lập trình viên), hoặc ít nhất nó cũng giúp bạn giải trí sau những giờ làm việc căng thẳng 😎.","title":"About"},{"content":"Coming soon \u0026hellip; ","permalink":"https://huydq.dev/projects/","summary":"Coming soon \u0026hellip; ","title":"Projects"}]