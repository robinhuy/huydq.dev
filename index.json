[{"content":"Vào một ngày đẹp trời, bỗng dưng mình nảy ra ý định làm một trang blog cá nhân thay vì viết Blog trên các nền tảng có sẵn như viblo.asia, techmaster.vn, kipalog.vn, \u0026hellip; Tất nhiên các bài viết mới vẫn sẽ đăng lên các nền tảng này để kiếm người đọc chứ blog này ma nó đọc 😅).\nÝ tưởng có rồi, nhưng thực hiện như nào, sử dụng công nghệ nào, chi phí như nào? Khá nhiều câu hỏi đau đầu và khó lựa chọn. Vậy cần đặt ra một số tiêu chí:\n Ưu tiên số một là chi phí, càng rẻ càng tốt, miễn phí thì còn tốt hơn nữa. Sử dụng công nghệ nào cũng được miễn là cài đặt nhanh, dễ dùng, dễ tùy biến. Blog có thể lượng truy cập ít (thậm chí không có ma nào xem), nhưng tốc độ truy cập vẫn phải nhanh, PageSpeed Insights điểm càng cao càng tốt.  Sau một hồi search Google với 3 tiêu chí trên (chủ yếu là tiêu chí miễn phí) thì mình chọn ra được giải pháp như sau:\n Sử dụng Static Site Generator, chơi web tĩnh thì tốc độ sẽ nhanh và điểm PageSpeed Insights sẽ cao. Cụ thể mình dùng tool Hugo. Hosting ở đâu? Tất nhiên là Github Page rồi, free, không giới hạn dung lượng và tốc độ cao. Các bạn cũng có thể dùng một số hosting free khác như: Netlify, Firebase, Vercel, \u0026hellip;  OK. Let\u0026rsquo;s get started!\nCài đặt và sử dụng Hugo Vào trang chủ của Hugo rồi làm theo hướng dẫn cài đặt tùy theo hệ điều hành mà bạn đang sử dụng thôi: https://gohugo.io/getting-started/installing.\nSau khi cài xong thì bật terminal lên và gõ lệnh sau để tạo một project web tĩnh (ví dụ huydq.dev):\nhugo new site huydq.dev Cấu trúc project tạo bởi Hugo như sau:\nTrong đó chúng ta chỉ cần chú ý đến mấy thư mục và file chính:\n content: Nơi viết nội dung cho website, là các file markdown, mỗi file tương ứng 1 trang trong website. theme: Chứa các theme có sẵn tải trên mạng về để làm giao diện cho website. config.toml: File cấu hình cho website như tên website, sử dụng theme gì, \u0026hellip; Có thể đổi sang định dạng yml hoặc yaml nếu không quen với toml.  Tiếp đến chúng ta vào trang này và chọn 1 cái theme ưng ý để cài. Có thể cài bằng cách download file về và ném vào trong thư mục themes hoặc là dùng git submodule để clone qua Github, ví dụ cài theme ananke qua Github:\ncd huydq.dev git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke Cài xong theme thì cần khai báo sử dụng ở trong file config, ví dụ:\nbaseURL = \u0026#34;https://huydq.dev/\u0026#34; title = \u0026#34;HuyDQ\u0026#39;s Blog\u0026#34; theme = \u0026#34;ananke\u0026#34; Trong này cũng cho phép khai báo cấu hình cho theme, cái này là tùy từng theme nên dùng theme nào thì xem ở hướng dẫn của theme đó.\nCấu hình xong theme thì chúng ta có thể bắt đầu viết blog bằng cách gõ lệnh sau để tạo ra một file markdown trong thư mục content (my-first-post.md):\nhugo new posts/my-first-post.md File mới tạo sẽ trông dạng như sau:\n--- title: \u0026#34;My First Post\u0026#34; date: 2019-03-26T08:47:11+01:00 draft: true --- Trong đó có cấu hình tên bài viết (title), ngày xuất bản (date), bản nháp hay đã sẵn sàng xuất bản (draft). Nội dung bài viết thì viết bằng cú pháp markdown, viết sau phần dấu gạch ngang ---. Bài viết nào có đánh dấu draft: true thì sẽ không được build.\nChạy thử website trên local bằng lệnh hugo server, truy cập http://localhost:1313 để xem kết quả. Đường dẫn của trang sẽ tương ứng với đường dẫn file http://localhost:1313/posts/my-first-post. Khi đã thấy ưng ý thì build ra static files (HTML CSS JS) bằng lệnh hugo. Website sẽ được build vào trong thư mục public và chỉ cần đẩy lên 1 hosting hỗ trợ static web là xong.\nCấu hình Github Pages Để sử dụng Github Pages hosting static web thì chúng ta tạo 1 repository trùng với tên miền free của Github Pages theo dạng [username].github.io, ví dụ username github của mình là robinhuy vậy mình sẽ tạo 1 repository là robinhuy.github.io (đây cũng chính là tên miền free của Github Pages).\nChúng ta có thể build website bằng Hugo, sau đó copy code web tĩnh ở trong thư mục public vào trong repository này và push code lên là xong.\nTuy nhiên nếu muốn quản lý cả source code thì chúng ta có thể đẩy toàn bộ project lên (bao gồm cả bản build). Và bản build sẽ được đẩy sang 1 branch là gh-pages, chúng ta sẽ cấu hình Github Pages bằng branch này.\nĐể cho tiện mình sử dụng thêm Github Actions cho việc tự động đẩy bản build sang branch gh-pages bằng cách tạo file .github/workflows/github-actions.yml trong project với nội dung như sau:\nname: GitHub Actions on: [push] jobs: deploy-website: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public Chỉ đơn giản vậy thôi, mỗi lần chúng ta push code lên branch main thì nó sẽ tự động đẩy code trong thư mục public sang branch gh-pages và website của chúng ta sẽ được cập nhật theo.\nChốt lại các thao tác khi cần viết bài mới sẽ là:\n   Tạo 1 file mới trong thư mục content, cấu hình nội dung trang và viết bài theo cú pháp markdown. Dùng lệnh hugo server để chạy website local (có sẵn live reload để tiện preview). Hoặc nếu muốn trải nghiệm viết bài như một CMS thì các bạn có thể cài thêm một số phần mềm theo hướng dẫn sau: https://gohugo.io/tools/frontends/.    Build website bằng lệnh hugo.    Commit code và push lên branch main.    Phần cấu hình website, cấu hình theme, \u0026hellip; thì các bạn tự tìm hiểu nốt trên trang chủ của Hugo và tài liệu hướng dẫn của theme mà bạn chọn nhé. Chúc các bạn viết Blog vui vẻ 😬\n","permalink":"https://huydq.dev/blog/cach-tao-mot-trang-blog-ca-nhan-mien-phi-danh-cho-dev/","summary":"Vào một ngày đẹp trời, bỗng dưng mình nảy ra ý định làm một trang blog cá nhân thay vì viết Blog trên các nền tảng có sẵn như viblo.asia, techmaster.vn, kipalog.vn, \u0026hellip; Tất nhiên các bài viết mới vẫn sẽ đăng lên các nền tảng này để kiếm người đọc chứ blog này ma nó đọc 😅).\nÝ tưởng có rồi, nhưng thực hiện như nào, sử dụng công nghệ nào, chi phí như nào?","title":"Cách tạo một trang blog cá nhân miễn phí dành cho dev"},{"content":"Để cho các App React hoạt động mượt mà hơn, đẹp hơn, trải nghiệm người dùng tốt hơn, \u0026hellip; thì nên có thêm các hiệu ứng animation, transition.\nBài viết này mình sẽ hướng dẫn các bạn sử dụng thư viện React Transition Group để tạo hiệu ứng transition một cách nhanh chóng.\nĐể cho tiện thì mình sẽ demo code trên stackblitz.com. Trong ví dụ sẽ sử dụng cả React Router v6 để cấu hình multiple page, và có hiệu ứng transition giữa các page. Dưới đây là danh sách các dependencies sử dụng trong ví dụ demo:\nCấu hình React Router (v6) React Transition Group cung cấp cho chúng ta 4 Component để hỗ trợ cho việc tạo transition, do đó mình sẽ tạo ra 4 page để demo, và có transition giữa các page.\nTạo ra 4 function Component rỗng đại diện cho mỗi page là Home.js, Page1.js, Page2.js, Page3.js. Ví dụ Component Home:\nimport React from \u0026#39;react\u0026#39;;  export default function Home() {  return (  \u0026lt;h1\u0026gt;Home Page\u0026lt;/h1\u0026gt;  ) } Sau đó cấu hình Router cho website ở App.js:\nimport React from \u0026#39;react\u0026#39;; import { BrowserRouter, Link, Routes, Route } from \u0026#39;react-router-dom\u0026#39;;  import Home from \u0026#39;./pages/Home\u0026#39;; import Page1 from \u0026#39;./pages/page1/Page1\u0026#39;; import Page2 from \u0026#39;./pages/page2/Page2\u0026#39;; import Page3 from \u0026#39;./pages/page3/Page3\u0026#39;;  export default function App() {  return (  \u0026lt;BrowserRouter\u0026gt;  {/* Tạo menu */}  \u0026lt;nav  style={{  borderBottom: \u0026#39;solid 1px\u0026#39;,  padding: \u0026#39;1rem 0\u0026#39;,  }}  \u0026gt;  \u0026lt;Link to=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/Link\u0026gt;  {\u0026#39; | \u0026#39;}  \u0026lt;Link to=\u0026#34;/page1\u0026#34;\u0026gt;Page 1\u0026lt;/Link\u0026gt;  {\u0026#39; | \u0026#39;}  \u0026lt;Link to=\u0026#34;/page2\u0026#34;\u0026gt;Page 2\u0026lt;/Link\u0026gt;  {\u0026#39; | \u0026#39;}  \u0026lt;Link to=\u0026#34;/page3\u0026#34;\u0026gt;Page 3\u0026lt;/Link\u0026gt;  \u0026lt;/nav\u0026gt;   {/* Cấu hình Route */}  \u0026lt;Routes\u0026gt;  \u0026lt;Route path=\u0026#34;/\u0026#34; element={\u0026lt;Home /\u0026gt;} /\u0026gt;  \u0026lt;Route path=\u0026#34;/page1\u0026#34; element={\u0026lt;Page1 /\u0026gt;} /\u0026gt;  \u0026lt;Route path=\u0026#34;/page2\u0026#34; element={\u0026lt;Page2 /\u0026gt;} /\u0026gt;  \u0026lt;Route path=\u0026#34;/page3\u0026#34; element={\u0026lt;Page3 /\u0026gt;} /\u0026gt;  \u0026lt;/Routes\u0026gt;  \u0026lt;/BrowserRouter\u0026gt;  ); } Sau khi cấu hình xong chúng ta có 1 website đơn giản gồm 4 trang, và có menu để chuyển trang.\nTiếp theo mình sẽ demo các Component mà React Transition Group cung cấp.\nTransition Component Dùng để tạo transition cho một Component khi nó thay đổi trạng thái (thường là chuyển đổi giữa mount và unmount).\nVí dụ sau sẽ tạo hiệu ứng transition khi Component xuất hiện (enter) và biến mất (exit):\nimport React, { useState } from \u0026#39;react\u0026#39;; import { Transition } from \u0026#39;react-transition-group\u0026#39;;  // Tạo một biến lưu thời gian chạy transition const duration = 1000; // 1000ms = 1s  // Có 4 trạng thái chính của một Transition // =\u0026gt; Tạo ra một object để style cho các trạng thái này const transitionStyles = {  entering: { opacity: 1 },  entered: { opacity: 1 },  exiting: { opacity: 0 },  exited: { opacity: 0 }, };  export default function Home() {  // Tạo state để ẩn hiện Component  const [isShow, setShow] = useState(false);   return (  \u0026lt;div\u0026gt;  \u0026lt;h1\u0026gt;Home\u0026lt;/h1\u0026gt;   {/* Sử dụng component Transition để tạo hiệu ứng transition */}  \u0026lt;Transition in={isShow} timeout={duration}\u0026gt;  {/* Nội dung bên trong là 1 hàm với tham số là state của Transition (4 state) */}  {(state) =\u0026gt; (  {/* Component sẽ hiển thị (hoặc biến mất) dựa vào state isShow */}  {/* Sử dụng inline style để tạo style transition */}  \u0026lt;div  style={{  transition: `opacity ${duration}ms ease-in-out`,  opacity: 0,  ...transitionStyles[state],  }}  \u0026gt;  Component content  \u0026lt;/div\u0026gt;  )}  \u0026lt;/Transition\u0026gt;   \u0026lt;br /\u0026gt;   {/* Bấm nút để hiển thị Component */}  \u0026lt;button onClick={() =\u0026gt; setShow(true)}\u0026gt;Show\u0026lt;/button\u0026gt;   {/* Bấm nút để ẩn Component */}  \u0026lt;button onClick={() =\u0026gt; setShow(false)}\u0026gt;Hide\u0026lt;/button\u0026gt;  \u0026lt;/div\u0026gt;  ); } CSSTransition Component Sử dụng CSS để tạo Transition. Compnent này tương tự Component Transition và kế thừa các thuộc tính của Component Transition.\nVí dụ sau tạo hiệu ứng tương tự như ví dụ trước, nhưng sử dụng CSS ở một file riêng:\nimport React, { useState } from \u0026#39;react\u0026#39;; import { CSSTransition } from \u0026#39;react-transition-group\u0026#39;; // Nhúng CSS từ file vào Component import \u0026#39;./style.css\u0026#39;;  export default function Page1() {  // Tạo state để ẩn hiện Component  const [isShow, setShow] = useState(false);   return (  \u0026lt;div\u0026gt;  \u0026lt;h1\u0026gt;Page 1\u0026lt;/h1\u0026gt;   {/* Sử dụng component CSSTransition để tạo hiệu ứng transition */}  {/* Chú ý classNames my-node sẽ được sử dụng ở file CSS để style */}  \u0026lt;CSSTransition in={isShow} timeout={1000} classNames=\u0026#34;my-node\u0026#34;\u0026gt;  \u0026lt;div className=\u0026#34;content\u0026#34;\u0026gt;Component content\u0026lt;/div\u0026gt;  \u0026lt;/CSSTransition\u0026gt;   \u0026lt;br /\u0026gt;   \u0026lt;button onClick={() =\u0026gt; setShow(true)}\u0026gt;Show\u0026lt;/button\u0026gt;  \u0026lt;button onClick={() =\u0026gt; setShow(false)}\u0026gt;Hide\u0026lt;/button\u0026gt;  \u0026lt;/div\u0026gt;  ); }``` ```CSS /* Thêm CSS để ban đầu ẩn luôn Component */ .content {  opacity: 0; }  /* Sử dụng class my-node và kèm thêm các suffix để style */  /* -enter: Component bắt đầu xuất hiện */ .my-node-enter {  opacity: 0; }  /* -enter-active: Component đang xuất hiện */ .my-node-enter-active {  opacity: 1;  transition: opacity 1000ms; }  /* -enter-done: Component kết thúc hiệu ứng xuất hiện */ .my-node-enter-done {  opacity: 1; }  /* -exit: Component bắt đầu biến mất */ .my-node-exit {  opacity: 1; }  /* -exit-active: Component đang biến mất */ .my-node-exit-active {  opacity: 0;  transition: opacity 1000ms; }  /* -exit-done: Component kết thúc hiệu ứng biến mất */ .my-node-exit-done {  opacity: 0; } SwitchTransition Component Sử dụng khi muốn điều khiển việc render Component theo state với 2 chế độ in-out và out-in (dùng kết hợp với Transition hoặc CSSTransition).\nVí dụ sau sẽ tạo transition khi thay đổi trạng thái của Component, nội dung của Component thay đổi kèm hiệu ứng transition:\nimport React, { useState } from \u0026#39;react\u0026#39;; import { SwitchTransition, CSSTransition } from \u0026#39;react-transition-group\u0026#39;; import \u0026#39;./style.css\u0026#39;;  export default function Home() {  const [state, setState] = useState(false);   return (  \u0026lt;div\u0026gt;  \u0026lt;h1\u0026gt;Page 2\u0026lt;/h1\u0026gt;   {/* Thử thay mode=\u0026#34;in-out\u0026#34; để xem hiệu ứng transition khác nhau */}  \u0026lt;SwitchTransition mode=\u0026#34;out-in\u0026#34;\u0026gt;  \u0026lt;CSSTransition  // Dùng key để phân biệt các trạng thái  key={state ? \u0026#39;out\u0026#39; : \u0026#39;in\u0026#39;}   // Sử dụng event transitionend để đánh dấu kết thúc transition  addEndListener={(node, done) =\u0026gt;  node.addEventListener(\u0026#39;transitionend\u0026#39;, done)  }   // Tạo hiệu ứng fade transition theo class \u0026#34;fade\u0026#34;  classNames=\u0026#34;fade\u0026#34;  \u0026gt;  \u0026lt;button onClick={() =\u0026gt; setState((state) =\u0026gt; !state)}\u0026gt;  {state ? \u0026#39;Goodbye!\u0026#39; : \u0026#39;Hello!\u0026#39;}  \u0026lt;/button\u0026gt;  \u0026lt;/CSSTransition\u0026gt;  \u0026lt;/SwitchTransition\u0026gt;  \u0026lt;/div\u0026gt;  ); } .fade-enter{  opacity: 0; } .fade-exit{  opacity: 1; } .fade-enter-active{  opacity: 1; } .fade-exit-active{  opacity: 0; } .fade-enter-active, .fade-exit-active{  transition: opacity 500ms; } TransitionGroup Component Sử dụng để tạo hiệu ứng transition cho 1 danh sách (list) các Component. Ví dụ demo mình lấy luôn trên docs của thư viện nhưng tối giản đi một chút:\nimport React, { useState } from \u0026#39;react\u0026#39;; import { CSSTransition, TransitionGroup } from \u0026#39;react-transition-group\u0026#39;; import { nanoid } from \u0026#39;nanoid\u0026#39;; import \u0026#39;./style.css\u0026#39;;  export default function Page3() {  // Tạo ra một list, sử dụng nanoid() để sinh unique id cho item  const [items, setItems] = useState([  { id: nanoid(), text: \u0026#39;Buy eggs\u0026#39; },  { id: nanoid(), text: \u0026#39;Pay bills\u0026#39; },  { id: nanoid(), text: \u0026#39;Invite friends over\u0026#39; },  { id: nanoid(), text: \u0026#39;Fix the TV\u0026#39; },  ]);   return (  \u0026lt;div\u0026gt;  \u0026lt;h1\u0026gt;Page 3\u0026lt;/h1\u0026gt;   \u0026lt;TransitionGroup className=\u0026#34;todo-list\u0026#34;\u0026gt;  {/* Render list, mỗi item trong list bọc trong Component CSSTransition */}  {items.map(({ id, text }) =\u0026gt; (  // Lấy id của item làm key cho CSSTransition  \u0026lt;CSSTransition key={id} timeout={500} classNames=\u0026#34;item\u0026#34;\u0026gt;  \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt;  {text}  \u0026lt;button  className=\u0026#34;btn-remove\u0026#34;  onClick={() =\u0026gt;  setItems((items) =\u0026gt; items.filter((item) =\u0026gt; item.id !== id))  }  \u0026gt;  \u0026amp;times;  \u0026lt;/button\u0026gt;  \u0026lt;/div\u0026gt;  \u0026lt;/CSSTransition\u0026gt;  ))}  \u0026lt;/TransitionGroup\u0026gt;   \u0026lt;button  className=\u0026#34;btn-add\u0026#34;  onClick={() =\u0026gt; {  const text = prompt(\u0026#39;Enter some text\u0026#39;);  if (text) {  setItems((items) =\u0026gt; [...items, { id: nanoid(), text }]);  }  }}  \u0026gt;  Add Item  \u0026lt;/button\u0026gt;  \u0026lt;/div\u0026gt;  ); } /* Style */ .container {  margin: 15px 0; } .btn-remove {  margin-left: 0.5rem; } .btn-add {  margin-top: 0.5rem; }  /* Transition */ .item-enter {  opacity: 0; } .item-enter-active {  opacity: 1;  transition: opacity 500ms ease-in; } .item-exit {  opacity: 1; } .item-exit-active {  opacity: 0;  transition: opacity 500ms ease-in; } Transition giữa các Page Để tạo transition giữa các page ta có thể dùng Component TransitionGroup. Tuy nhiên cần có key phân biệt giữa các Component được render. Mình sử dụng đường dẫn để làm key, do đó cần sử dụng thêm hook useLocation của React Router để lấy ra được đường dẫn.\nHook useLocation chỉ sử dụng được khi nằm trong Component BrowserRouter nên chúng ta phải tạo thêm 1 Component con để tạo transition. Tạo thêm một Component là RoutesWithTransition:\nimport React from \u0026#39;react\u0026#39;; import { Routes, Route, useLocation } from \u0026#39;react-router-dom\u0026#39;; import { TransitionGroup, CSSTransition } from \u0026#39;react-transition-group\u0026#39;; import Home from \u0026#39;./pages/Home\u0026#39;; import Page1 from \u0026#39;./pages/page1/Page1\u0026#39;; import Page2 from \u0026#39;./pages/page2/Page2\u0026#39;; import Page3 from \u0026#39;./pages/page3/Page3\u0026#39;; import \u0026#39;./style.css\u0026#39;;  export default function RoutesWithTransition() {  // Lấy ra location dùng hook useLocation  const location = useLocation();   return (  \u0026lt;TransitionGroup\u0026gt;  {/* Dùng location.pathname làm key */}  \u0026lt;CSSTransition key={location.pathname} classNames=\u0026#34;slide\u0026#34; timeout={300}\u0026gt;  \u0026lt;Routes\u0026gt;  \u0026lt;Route path=\u0026#34;/\u0026#34; element={\u0026lt;Home /\u0026gt;} /\u0026gt;  \u0026lt;Route path=\u0026#34;/page1\u0026#34; element={\u0026lt;Page1 /\u0026gt;} /\u0026gt;  \u0026lt;Route path=\u0026#34;/page2\u0026#34; element={\u0026lt;Page2 /\u0026gt;} /\u0026gt;  \u0026lt;Route path=\u0026#34;/page3\u0026#34; element={\u0026lt;Page3 /\u0026gt;} /\u0026gt;  \u0026lt;/Routes\u0026gt;  \u0026lt;/CSSTransition\u0026gt;  \u0026lt;/TransitionGroup\u0026gt;  ); } Sau đó đổi lại phần cấu hình routes ở App.js sử dụng Component trên:\n...  \u0026lt;BrowserRouter\u0026gt;  \u0026lt;nav\u0026gt;...\u0026lt;/nav\u0026gt;   {/* Config routes */}  \u0026lt;RoutesWithTransition /\u0026gt;  \u0026lt;/BrowserRouter\u0026gt; ... Tham khảo toàn bộ code mẫu tại đây: https://stackblitz.com/edit/react-transition-group-react-router-v6?file=src/App.js.\nHappy coding 😎\n","permalink":"https://huydq.dev/blog/tao-hieu-ung-transition-cho-react-app-voi-react-transition-group/","summary":"Để cho các App React hoạt động mượt mà hơn, đẹp hơn, trải nghiệm người dùng tốt hơn, \u0026hellip; thì nên có thêm các hiệu ứng animation, transition.\nBài viết này mình sẽ hướng dẫn các bạn sử dụng thư viện React Transition Group để tạo hiệu ứng transition một cách nhanh chóng.\nĐể cho tiện thì mình sẽ demo code trên stackblitz.com. Trong ví dụ sẽ sử dụng cả React Router v6 để cấu hình multiple page, và có hiệu ứng transition giữa các page.","title":"Tạo hiệu ứng transition cho React App với React Transition Group"},{"content":"Trước khi đẩy app lên Store, chúng ta sẽ cần tạo App Launcher Icon (icon của ứng dụng trên máy của người dùng). App code bằng React Native sẽ có thể đẩy lên cả Google Play (Android) và App Store (iOS), do đó mình sẽ hướng dẫn cách tạo App Launcher Icon cho cả 2 hệ hiều hành trên.\n1. App Launcher Icon cho iOS Bước 1 Đầu tiên chúng ta cần phải có 1 ảnh icon được thiết kế sẵn với kích thước 1024x1024 pixels (hoặc lớn hơn cũng được).\nTiếp đến các bạn có thể dùng tool Icon Set Creator (trên App Store) để tạo ra bộ icon với các kích thước khác nhau cho các loại thiết bị iOS.\n  Kéo thả ảnh, chọn Platform và thư mục lưu ảnh là xong   Hoặc các bạn có thể truy cập website https://makeappicon.com/, upload ảnh lên (JPG hoặc PNG) và nhập email để nhận bộ icon trên cả iOS lẫn Android.\n  Upload ảnh lên website     Xem preview Icon, nhập email để nhận bộ icon   Bước 2 Bật XCode lên, mở project React Native (file [project] .xcworkspace trong thư mục ios).\nTìm đến thư mục Images.xcassets, sau đó kéo thả bộ icon đã được tạo từ bước 1 (thư mục AppIcon.appiconset) hoặc bấm vào biểu tượng dấu cộng ở góc dưới bên trái, chọn import.\nXong, build lại app để thấy kết quả 😎.\n 1 phút quảng cáo: Icon ở trên là mình tự chế cho app game Master Mind X viết bằng React Native, anh chị em chơi thử rồi cho xin góp ý ở comment nhé, review ủng hộ 5 sao thì càng tốt 😆\n 2. App Launcher Icon cho Android Bước 1 Làm tương tự như bên iOS, chúng ta cũng cần 1 ảnh icon với kích thước tối thiểu 1024x1024 pixels. Sau đó dùng trang web sau để tạo bộ icon: Android Assets Studio\nBước 2 Giải nén bộ icon vừa download về, trong đó có thư mục res chứa các thư mục dạng: mipmap-hdpi, mipmap-mdpi, mipmap-xhdpi, \u0026hellip;, trong mỗi thư mục lại chứa file ic_launcher (tên mặc định). Copy (ghi đè) toàn bộ vào trong thư mục android \u0026gt; app \u0026gt; src \u0026gt; main \u0026gt; res.\nChú ý là có nhiều thiết bị android sử dụng icon dạng hình tròn, nên chúng ta tạo thêm 1 bộ icon dạng tròn (Circle) và cũng copy như trên, tên icon mặc định sẽ là ic_launcher_round.\n  Tên icon đã được khai báo sẵn trong file **AndroidManifest.xml**     Import Icons   Chú ý: Theo khuyến nghị của Google thì nên thiết kế icon cho Android theo dạng hình vuông đầy đủ (không cần bo tròn), không đổ bóng, vì khi đẩy app lên Store thì Google sẽ tự áp dụng các kiểu hiệu ứng đó cho đồng nhất. Do đó với bộ icons hình vuông thì có thể dùng luôn bộ icon tạo từ trang https://makeappicon.com/, còn nếu tạo từ trang Android Assets Studio thì bỏ hết cấu hình phần Effect (để None).\nTham khảo thêm: https://developer.android.com/google-play/resources/icon-design-specifications\n","permalink":"https://huydq.dev/blog/tao-app-launcher-icon-cho-react-native-app-android-ios/","summary":"Trước khi đẩy app lên Store, chúng ta sẽ cần tạo App Launcher Icon (icon của ứng dụng trên máy của người dùng). App code bằng React Native sẽ có thể đẩy lên cả Google Play (Android) và App Store (iOS), do đó mình sẽ hướng dẫn cách tạo App Launcher Icon cho cả 2 hệ hiều hành trên.\n1. App Launcher Icon cho iOS Bước 1 Đầu tiên chúng ta cần phải có 1 ảnh icon được thiết kế sẵn với kích thước 1024x1024 pixels (hoặc lớn hơn cũng được).","title":"Tạo App Launcher icon cho React Native app (Android + iOS)"},{"content":"Không lập trình viên nào code mà không có bug. Tuy nhiên có rất nhiều lỗi cơ bản chúng ta nên tránh để tạo ra ít bug hơn, code sạch và trong sáng hơn, dễ bảo trì hơn, đỡ bị ăn chửi hơn, …\n1. Xử lý quá nhiều thứ trong một function Theo nguyên tắc Single Responsibility, một function chỉ nên thực hiện một và chỉ một nhiệm vụ duy nhất. Nhiều lập trình viên hay viết một function vừa lấy dữ liệu, xử lý dữ liệu và hiển thị dữ liệu. Thay vì như vậy, hãy chia nhỏ function này ra làm 3 function: Function lấy dữ liệu, function xử lý dữ liệu và function hiển thị dữ liệu.\nViệc giữ một function chỉ tập trung thực hiện một nhiệm vụ sẽ giúp code dễ đọc và dễ bảo trì hơn. Như ví dụ trên, giả sử API để lấy dữ liệu bị thay đổi thì ta chỉ cần cập nhật lại function lấy dữ liệu, không bị ảnh hưởng đến các thao tác ở sau.\n2. Code bị comment Trong một ứng dụng lớn có nhiều lập trình viên tham gia, nhiều khi bạn sẽ thấy có các hàm, các đoạn code lớn bị comment. Bạn sẽ không hiểu đoạn code bị comment này để làm gì, ý đồ của tác giả là gì. Các lập trình viên khác có thể sẽ không dám xoá đoạn code này vì có thể tác giả của đoạn comment còn cần đến nó.\nNếu gặp trường hợp như vậy và project có sử dụng hệ thống quản lý code như git, svn, … thì hãy mạnh dạn xoá đoạn code này đi, code sẽ trở nên sạch đẹp hơn. Còn sau này nếu tác giả của đoạn code đó muốn tìm lại thì họ sẽ phải tự tìm trong các commit cũ.\n3. Đặt tên biến, tên hàm không rõ ràng Đặt tên biến là một công việc khó nhưng cũng rất quan trọng. Một tên biến rõ ràng sẽ giúp việc đọc code trở nên dễ dàng, dễ hiểu.\nHãy đặt tên biến mô tả đúng chức năng, ý nghĩa của nó, dài một chút cũng được. Tránh đặt tên biến kiểu viết tắt (trừ trường hợp phổ biến hoặc đã thống nhất từ trước) hoặc tên biến không có ý nghĩa như a, b, c, …\n4. Magic number và string Magic number và string là các giá trị duy nhất được sử dụng nhiều lần trong ứng dụng mà không có giải thích ý nghĩa rõ ràng. Những giá trị này hoàn toàn có thể thay thế bằng các biến (với điều kiện biến phải được đặt tên một cách rõ ràng).\nVí dụ với đoạn code sau:\nfor ($i = 1; $i \u0026lt;= 52; $i++) {  ... } Trong ví dụ trên thì 52 là một magic number, và người đọc code sẽ không hiểu được 52 có ý nghĩa là gì. Thậm chí kể cả tác giả đoạn code, sau một thời gian quay lại đọc code của mình cũng không hiểu, phải dò lại toàn bộ chương trình.\nĐoạn code trên có thể viết lại như sau:\n$cardDeckSize = 52; for ($i = 1; $i \u0026lt;= $cardDeckSize; $i++) {  ... } Như vậy đọc đoạn code này sẽ hiểu ngay là đang thực hiện một vòng lặp qua từng quân bài trong bộ bài và 52 có nghĩa là số lá bài trong bộ bài. Ở các phần bên dưới cũng có thể dùng lại biến $cardDeckSize và khi cần thay đổi giá trị số lượng lá bài trong bộ bài ta cũng chỉ cần thay đổi giá trị của biến này một lần duy nhất thay vì phải sửa nhiều chỗ.\nTương tự với number, chúng ta cũng có magic string:\nif (userPasswordIsValid($user, \u0026#34;6yP4cZ\u0026#34;.$password)) {  ... } Thay vì viết như trên ta viết lại:\n$salt = \u0026#34;6yP4cZ\u0026#34;; if (userPasswordIsValid($user, $salt.$password)) {  ... } và code sẽ trở nên dễ hiểu hơn.\n5. Code format lộn xộn Với những lập trình viên không có kinh nghiệm và cẩu thả thì họ sẽ viết code lộn xộn, không có format. Code không format sẽ rất khó đọc và dễ dẫn đến code sai cú pháp và rất khó debug. Ví dụ như code HTML có thẻ mở mà không có thẻ đóng dẫn đến sai cấu trúc code làm hỏng cả CSS, lỗi này cũng khó debug vì dù code sai thì cũng sẽ không báo lỗi lên trình duyệt.\nĐa số các IDE hoặc code editor hiện đại đều có hỗ trợ chức năng format code theo từng ngôn ngữ, hoặc là người dùng chủ động cài thêm các plugin, extension hỗ trợ cho việc format code. Trong một project nếu các lập trình viên dùng chung một chuẩn format code cũng sẽ giúp code đồng bộ và ít bị xung đột.\n6. Hard code Hard code là nhập dữ liệu trực tiếp vào trong source code, dữ liệu này bị fix cứng và không thay đổi, cấu hình được.\nTrong một số trường hợp chúng ta vẫn dùng hard code, tuy nhiên nếu code của bạn bị hard code quá nhiều tức là đang có vấn đề. Thay vì hard code dữ liệu trong source code, hãy tách chúng ra bằng cách lấy dữ liệu qua file cấu hình, lấy từ cơ sở dữ liệu hoặc API, hay qua biến môi trường, …\nBài viết được biên dịch lại từ medium.com.\n","permalink":"https://huydq.dev/blog/nhung-loi-co-ban-trong-lap-trinh-ma-developer-nen-tranh/","summary":"Không lập trình viên nào code mà không có bug. Tuy nhiên có rất nhiều lỗi cơ bản chúng ta nên tránh để tạo ra ít bug hơn, code sạch và trong sáng hơn, dễ bảo trì hơn, đỡ bị ăn chửi hơn, …\n1. Xử lý quá nhiều thứ trong một function Theo nguyên tắc Single Responsibility, một function chỉ nên thực hiện một và chỉ một nhiệm vụ duy nhất.","title":"Những lỗi cơ bản trong lập trình mà developer nên tránh"},{"content":"Sau khi code xong 1 ứng dụng bằng Create React App, chúng ta có thể đẩy sản phẩm lên Internet theo 1 trong 3 cách miễn phí sau chỉ với 3 bước (còn nhiều cách khác nhưng tác giả lười viết 😅):\n1. Github Pages Giả sử bạn đã có tài khoản trên github là robinhuy, và có 1 repository chứa source code ứng dụng tạo bởi Create React App là react-app.\nBước 1: Cài thêm thư viện gh-pages (devDependencies)\nnpm i gh-pages --save-dev Bước 2: Sửa lại file package.json, bổ sung thêm thuộc tính homepage, và scripts\nBước 3: Deploy lên Github Pages bằng lệnh\nnpm run deploy Sau đó truy cập ứng dụng tại địa chỉ: robinhuy.github.io/react-app\n2. ZEIT Now Bước 1: Cài đặt Now CLI\nnpm i -g now Bước 2: Tạo tài khoản trên https://zeit.co và đăng nhập bằng Now CLI (gõ email rồi truy cập email để xác thực)\nnow login Bước 3: Đẩy code lên bằng lệnh\nnow Chú ý nếu đẩy code lên ZEIT Now thì không cấu hình homepage như Github Pages vì mỗi project sẽ có subdomain riêng. Có thể kết nối với Github để mỗi lần push code lên Github sẽ tự động deploy lên Now.\n3. Heroku Bước 1: Tạo tài khoản trên https://heroku.com, sau đó tạo 1 App (tương tự tạo repository trên Github). Truy cập mục Settings của App vừa tạo để add thêm buildpack với địa chỉ https://github.com/mars/create-react-app-buildpack\nBước 2: Cài Heroku CLI, sau đó đăng nhập tương tự ZEIT Now\nheroku login Bước 3: Đẩy code lên tương tự như đẩy code lên Github\nheroku git:remote -a react-app git push heroku master heroku open Chú ý nếu đẩy code lên Heroku thì không cấu hình homepage như Github Pages vì mỗi project sẽ có subdomain riêng. Có thể kết nối với Github để mỗi lần push code lên Github sẽ tự động deploy lên Heroku.\n","permalink":"https://huydq.dev/blog/day-code-create-react-app-len-internet-mien-phi/","summary":"Sau khi code xong 1 ứng dụng bằng Create React App, chúng ta có thể đẩy sản phẩm lên Internet theo 1 trong 3 cách miễn phí sau chỉ với 3 bước (còn nhiều cách khác nhưng tác giả lười viết 😅):\n1. Github Pages Giả sử bạn đã có tài khoản trên github là robinhuy, và có 1 repository chứa source code ứng dụng tạo bởi Create React App là react-app.","title":"Đẩy code Create React App lên Internet miễn phí"},{"content":"Bài viết được dịch từ uxdesign.cc, có lược bớt và chỉnh sửa theo sở thích của người dịch 😜\nNhững lỗi thiết kế form và cách tối ưu Form là một thành phần rất quan trọng trên website. Bài viết này sẽ chỉ ra những điều nên và không nên khi thiết kế Form. Chú ý đây chỉ là đề xuất chứ không phải nguyên lý nên sẽ có ngoại lệ.\nNhóm label với input của nó Trình bày Label và Input của nó gần nhau hơn, khoảng cách giữa các trường với nhau phải đủ lớn để User không bị nhầm lẫn giữa các trường.\nTránh viết hoa toàn bộ Label viết hoa toàn bộ sẽ khiến User khó đọc hơn.\nNếu có 5 lựa chọn trở xuống, hãy hiển thị toàn bộ ra Nếu đặt các lựa chọn trong Dropdown thì các lựa chọn này sẽ bị ẩn và User cũng phải bấm 2 lần để chọn. Chỉ nên dùng Dropdown khi có nhiều lựa chọn và khi có quá nhiều lựa chọn thì nên dùng Dropdown kết hợp Search trong Dropdown.\nĐặt các lựa chọn Checkbox (hoặc Radio) theo chiều dọc để dễ theo dõi Xếp theo chiều dọc thì đọc lướt sẽ dễ hơn.\nMô tả rõ Call To Action (CTA) Nút kêu gọi hành động phải có nội dung rõ ràng, không khiến User phân vân.\nChỉ rõ lỗi ngay trên dòng Chỉ rõ lỗi ở dòng nào và là lỗi gì.\nĐừng ẩn các chỉ dẫn Luôn hiển thị các chỉ dẫn khi có thể và đặt nó ở gần input.\nPhân biệt Action chính và phụ Action chính cần nổi bật hơn action phụ.\nĐể độ dài ô input phù hợp Độ dài của ô input nên tương đương với dữ liệu User sẽ nhập cho input đó. Ví dụ những trường như Zip code, số điện thoại, … không nên để quá dài.\nBỏ dấu sao (*, mang ý nghĩa bắt buộc) và thay bằng ghi chú Optional (tùy chọn, không bắt buộc) Nhìn dấu sao nhiều khó chịu và không phải ai cũng biết dấu sao nghĩa là bắt buộc. Ghi chú rõ ràng những trường không bắt buộc sẽ tốt hơn.\nGom nhóm các thông tin liên quan Với những Form dài thì việc gom nhóm các thông tin liên quan lại với nhau sẽ giúp User dễ theo dõi hơn.\nHãy luôn tự hỏi Bỏ bớt những trường tùy chọn đi và nghĩ ra những cách khác để thu thập dữ liệu từ User. Thời gian là vàng bạc và User sẽ không muốn mất nhiều thời gian để nhập dữ liệu vào Form.\nHãy luôn tự hỏi xem những thông tin nào thật sự cần thiết cho vào Form, những dữ liệu nào có thể bỏ đi hoặc để thu thập sau.\nViệc thu thập dữ liệu đang theo hướng tự động hóa. Ví dụ như điện thoại di động hoặc đồng hồ thông minh có thể thu thập rất nhiều dữ liệu từ User trong khi họ không hề hay biết. Hãy nghĩ theo cách tận dụng mạng xã hội, tin nhắn, email, địa điểm, … để lấy thông tin từ User.\n","permalink":"https://huydq.dev/blog/lam-sao-de-thiet-ke-form-tot-hon/","summary":"Bài viết được dịch từ uxdesign.cc, có lược bớt và chỉnh sửa theo sở thích của người dịch 😜\nNhững lỗi thiết kế form và cách tối ưu Form là một thành phần rất quan trọng trên website. Bài viết này sẽ chỉ ra những điều nên và không nên khi thiết kế Form. Chú ý đây chỉ là đề xuất chứ không phải nguyên lý nên sẽ có ngoại lệ.","title":"Làm sao để thiết kế Form tốt hơn?"},{"content":"Bài viết được biên dịch và tóm tắt lại từ https://towardsdatascience.com , code demo được chuyển sang dùng Hooks.\nXử lý dữ liệu trong React có thể hơi khó khăn một chút, nhưng cũng không quá phức tạp. Tôi đã tổng kết lại 3 cách để truyền dữ liệu giữa các Component trong React:\n Từ Parent (Component cha) đến Child (Component con) sử dụng Props. Từ Child đến Parent sử dụng Callbacks. Giữa các Siblings (anh em, họ hàng, hàng xóm, \u0026hellip;)  Kết hợp cách 1 và 2. Sử dụng Redux(hoặc các thư viện có chức năng tương tự). Sử dụng Context API của React.    1. Từ Parent đến Child sử dụng Props Giả sử ứng dụng có cấu trúc Component như sau:\nĐây là trường hợp phổ biến và dễ nhất khi truyền dữ liệu trong React.\nimport React, {useState} from \u0026#39;react\u0026#39;;  function Parent() {  const [data, setData] = useState(\u0026#39;Hello World\u0026#39;)   return (  \u0026lt;div\u0026gt;  \u0026lt;Child1/\u0026gt; // Không truyền dữ liệu  \u0026lt;Child2 dataFromParent=\u0026#34;Hello\u0026#34; /\u0026gt; // Truyền dữ liệu qua Props  \u0026lt;Child2 dataFromParent={data} /\u0026gt; // Truyền dữ liệu qua Props  \u0026lt;/div\u0026gt;  ); } Ở Child component chỉ cần dùng props.dataFromParent để lấy dữ liệu đã được truyền từ Parent ( dataFromParent chỉ như một biến, một thuộc tính tự mình đặt ra để truyền dữ liệu qua props):\nfunction Child2(props) {  return (  \u0026lt;div\u0026gt;  Dữ liệu nhận được từ Parent: {props.dataFromParent}  \u0026lt;/div\u0026gt;  ); } 2. Từ Child đến Parent sử dụng Callbacks Để truyền dữ liệu từ Child lên Parent chúng ta thực hiện theo các bước sau:\nBước 1: Định nghĩa 1 callback function ở Parent component, function này sẽ có tham số để chứa dữ liệu được truyền đi từ Child component.\nBước 2: Truyền callback function đã được định nghĩa ở trên vào Child component qua props (tương tự truyền dữ liệu từ Parent đến Child).\nimport React, {useState} from \u0026#39;react\u0026#39;;  function Parent() {  const [message, setMessage] = useState(\u0026#39;\u0026#39;)   callbackFunction = (childData) =\u0026gt; {  setMessage(childData)  },   return (  \u0026lt;div\u0026gt;  \u0026lt;Child parentCallback={callbackFunction}/\u0026gt;  \u0026lt;p\u0026gt; {message} \u0026lt;/p\u0026gt;  \u0026lt;/div\u0026gt;  ); } Bước 3: Ở Child component truyền dữ liệu ngược lại Parent bằng cách gọi props.callback(dataToParent)\nfunction Child(props) {  sendData = () =\u0026gt; {  props.parentCallback(\u0026#34;Message from Child\u0026#34;);  },   return (  // Gọi function sendData bất cứ khi nào bạn muốn truyền dữ liệu lên Parent component (khi có sự kiện xảy ra như onClick, onChange, ...)  ) }; Truyền dữ liệu giữa các Siblings Cách 1: Kết hợp 2 cách truyền dữ liệu ở trên Cách này chỉ dùng trong trường hợp đơn giản, không nên sử dụng trong trường hợp các Component lồng nhiều cấp (cây gia phả quá lớn, họ hàng bắn đại bác không tới), vì code sẽ trùng lặp nhiều và khó theo dõi luồng dữ liệu.\nCách 2: Sử dụng một Global store (Redux) để quản lý State cho tất cả các Component cần truyền dữ liệu và tương tác với nhau Cách 3: Sử dụng Context API của React Tham khảo thêm 1 số bài viết giới thiệu về React Context API:\n Using Context in React React Context API — A Replacement for Redux? You Might Not Need Redux  ","permalink":"https://huydq.dev/blog/truyen-du-lieu-giua-react-components/","summary":"Bài viết được biên dịch và tóm tắt lại từ https://towardsdatascience.com , code demo được chuyển sang dùng Hooks.\nXử lý dữ liệu trong React có thể hơi khó khăn một chút, nhưng cũng không quá phức tạp. Tôi đã tổng kết lại 3 cách để truyền dữ liệu giữa các Component trong React:\n Từ Parent (Component cha) đến Child (Component con) sử dụng Props. Từ Child đến Parent sử dụng Callbacks.","title":"Truyền dữ liệu giữa React Components"},{"content":"Video demo: https://youtu.be/O6Agt4cLbfo.\nDựng Server local Yêu cầu máy tính đã cài và chạy được Git + NodeJS.\nCác bước thực hiện:\n  Clone repository sau (hoặc fork về nếu muốn quản lý source code, nhớ star để ủng hộ tác giả): https://github.com/robinhuy/fake-rest-api-nodejs.git\n git clone https://github.com/robinhuy/fake-rest-api-nodejs.git   Cài đặt dependencies\n cd fake-rest-api-nodejs  npm install   Chạy server\n npm start   Vậy là chúng ta đã có 1 Server API chạy trên http://localhost:3000 với 1 resource có sẵn là /users với các API theo chuẩn REST:\nGET /users GET /users/1 POST /users PUT /users/1 PATCH /users/1 DELETE /users/1 Ngoài ra Server còn cung cấp thêm 1 phương thức Authentication bằng JWT (Bearer token), xác thực user bằng email và password qua API:\nPOST /login (dữ liệu truyền lên dạng { email: \u0026ldquo;example@gmail.com\u0026rdquo;, password: \u0026ldquo;secret\u0026rdquo; }, thông tin lấy trong resource users).\nNhững resource và method được khai báo trong protected_resources thì cần đăng nhập để thực hiện, ví dụ:\n\u0026#34;protected_resources\u0026#34;: {  \u0026#34;users\u0026#34;: [\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;PATCH\u0026#34;, \u0026#34;DELETE\u0026#34;],  \u0026#34;products\u0026#34;: [\u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;PATCH\u0026#34;, \u0026#34;DELETE\u0026#34;] } Nếu bạn muốn tuỳ chỉnh lại hoặc bổ sung cơ chế Authentication thì có thể chỉnh sửa lại ở file server.js phần Access control\nChú ý: Sau khi chỉnh sửa code cần khởi động lại server!\nChỉnh sửa API API mặc định là thông tin về User, toàn bộ được lưu vào trong file database.json. Có thể chỉnh sửa hoặc thêm dữ liệu vào file đó miễn khai báo đúng cấu trúc (chú ý users hiện đang được dùng luôn cho cả authentication). Ví dụ thêm 1 resource về products:\nServer sử dụng thư viện JSON Server, để xem đầy đủ tài liệu hướng dẫn về API hãy xem tại đây: https://github.com/typicode/json-server\nNếu cần mockup dữ liệu lớn và ngẫu nhiên thì có thể dùng thêm dịch vụ sau https://mockaroo.com/. Mockaroo cho phép mockup dữ liệu rất đa dạng, cấu hình được tỉ lệ, viết thêm các function điều kiện để tạo dữ liệu và cho phép xuất mockup ra dưới nhiều định dạng trong đó có JSON.\nDựng server online Nếu là đại gia thì có thể sử dụng VPS hoặc nếu không thì có thể sử dụng dịch vụ của Heroku (hoặc các dịch vụ tương tự): Đăng ký tài khoản, tạo App và đẩy source code kèm file database.json lên. Khi deploy code có thể chọn Heroku Git và gõ lệnh theo hướng dẫn bên dưới hoặc chọn kết nối với Github repo để deploy code qua 1 nút bấm (hoặc auto deploy khi có commit lên github).\nCần chú ý là nếu dùng gói Free thì khi Server không hoạt động (không có truy cập) sau 30 phút thì Server sẽ rơi vào trạng thái Sleep, lần truy cập kế tiếp sẽ hơi chậm 1 chút và mọi dữ liệu sẽ reset về ban đầu (như trong file database.json).\n=\u0026gt; Nếu dùng Heroku để host thì có thể chọc phá API thoải mái 😄\n","permalink":"https://huydq.dev/blog/tao-1-rest-api-phuc-vu-cho-muc-dich-hoc-tap-trong-30-giay/","summary":"Video demo: https://youtu.be/O6Agt4cLbfo.\nDựng Server local Yêu cầu máy tính đã cài và chạy được Git + NodeJS.\nCác bước thực hiện:\n  Clone repository sau (hoặc fork về nếu muốn quản lý source code, nhớ star để ủng hộ tác giả): https://github.com/robinhuy/fake-rest-api-nodejs.git\n git clone https://github.com/robinhuy/fake-rest-api-nodejs.git   Cài đặt dependencies\n cd fake-rest-api-nodejs  npm install   Chạy server\n npm start   Vậy là chúng ta đã có 1 Server API chạy trên http://localhost:3000 với 1 resource có sẵn là /users với các API theo chuẩn REST:","title":"Tạo 1 REST API phục vụ cho mục đích học tập trong 30 giây"},{"content":"Note: Pug ở đây là 1 View Template Engine (chứ không phải tên 1 loại chó), có thể dùng ở cả phía Server lẫn Client. Trong bài viết này sẽ hướng dẫn sử dụng Pug phía client cho Frontend Dev.\nTạo khung project Sau khi đã thiết kế xong giao diện website, chúng ta sẽ bắt đầu xây dựng khung project. Ví dụ cấu trúc thông thường của 1 project web tĩnh:\nVới cấu trúc trên chúng ta có mỗi file HTML tương ứng với 1 trang tĩnh. Trong cùng 1 website thì các trang tĩnh có thể dùng chung các thành phần giống nhau (header, footer, sidebar, \u0026hellip;), dẫn đến việc code bị trùng lặp khó bảo trì. Trong 1 trang tĩnh cũng có thể có số lượng code rất lớn (ví dụ trang chủ, landing page) thì cũng sẽ khó đọc và bảo trì. Do đó chúng ta nên chia nhỏ các file html ra tương tự như khi chia nhỏ các file CSS và Javascript. Ví dụ:\nMặc định trong HTML không cho phép nhúng 1 file HTML khác, trừ khi dùng Javascript thao tác với DOM. Và Pug sẽ giúp chúng ta làm việc này bằng cách code HTML theo cú pháp của Pug (ngắn gọn hơn HTML thuần và cho phép include file) sau đó dùng pug-cli để chuyển từ Pug template sang code HTML. Lúc này cấu trúc project sẽ có dạng như sau:\nCài đặt Để sử dụng Pug chúng ta sẽ cần cài đặt lên máy qua 2 bước sau:\n  Bước 1: Cài đặt NodeJS trên trang https://nodejs.org, nên chọn bản LTS (Long Term Support - Recommended for most users). Sau khi cài xong chúng ta sẽ có luôn npm dùng để cài các thư viện rất hữu ích trong việc phát triển web, trong đó có Pug.\n  Bước 2: Cài đặt Pug qua NPM (chú ý ở đây mình cài pug-cli để chạy các lệnh của pug qua command line):\n  npm install -g pug-cli Sử dụng pug-cli Tạo khung project như bình thường, nhưng không có file HTML, chúng ta sẽ code bằng template engine Pug rồi dùng pug-cli để tạo ra các file HTML.\nTạo thêm 1 thư mục là template (hoặc đặt tên khác cũng được, không bắt buộc). Thư mục này sẽ chứa các file template Pug, còn file HTML được tạo ra thì sẽ nằm ở bên ngoài như bình thường. Trong thư mục template cũng có thể chia nhỏ ra thành nhiều thư mục con để gom nhóm các file nếu như số lượng file lớn (ví dụ ở đây mình tạo thêm thư mục template-part để chứa các template nhỏ là các thành phần nhỏ trong 1 trang).\nSau khi tạo xong các file .pug thì chúng ta bật terminal tại thư mục gốc của project và chạy lệnh sau để bật pug-cli:\npug -w ./template -o ./ -P Khi chạy lệnh thành công thì chương trình sẽ theo dõi thay đổi ở file .pug và tự động render ra file .html ở bên ngoài. Chú ý các options trong lệnh trên:\n -w (watch - những file cần theo dõi thay đổi để render ra HTML), trong trường hợp này là tất cả các file trong thư mục template. -o (output - nơi xuất ra những file HTML được render từ file pug), trong trường hợp này là thư mục hiện tại (thư mục gốc của project, nơi chạy lệnh trên). -P (pretty - xuất ra HTML có format code). Option này có thể bỏ đi nếu không cần format đẹp, code xuất ra sẽ dồn hết lại thành 1 dòng.  Ví dụ code Tạo 1 file là layout.pug đặt trong thư mục template/template-part, file này sẽ là khung giao diện chung cho toàn bộ website (nếu website có nhiều kiểu layout thì tạo nhiều file layout):\nCú pháp của template tương tự code HTML nhưng tối giản đi, chỉ cần tên thẻ, không cần thẻ đóng, nhưng cần chú ý thụt dòng đúng. Ngoài ra có thể dùng include để nhúng nội dung 1 file này vào file khác (ví dụ nhúng nội dung menu.pug và footer.pug vào layout.pug).\nTạo 1 file là index.pug nằm trong thư mục template (trang chủ, sẽ render ra trang index.html). Trang này \u0026ldquo;kế thừa\u0026rdquo; (extends) layout trên và chỉ thay đổi nội dung các block:\nCác trang khác thì làm tương tự trang chủ.\nSau khi tạo xong các trang thì chạy lại lệnh pug như hướng dẫn phần cài đặt. Nếu đã chạy rồi thì phải tắt đi chạy lại khi có thêm file template mới bằng cách bấm Ctrl + C\nXong phần cài đặt và thiết lập project, phần tiếp theo là học qua 1 số cú pháp cơ bản của Pug (không cần phải biết hết) và \u0026ldquo;cắt HTML CSS từ giao diện có sẵn\u0026rdquo; các bạn hãy tự làm nốt nhé, bài viết đến đây là quá dài rồi.\nHappy coding!!!\n","permalink":"https://huydq.dev/blog/code-web-tinh-de-hon-voi-pug/","summary":"Note: Pug ở đây là 1 View Template Engine (chứ không phải tên 1 loại chó), có thể dùng ở cả phía Server lẫn Client. Trong bài viết này sẽ hướng dẫn sử dụng Pug phía client cho Frontend Dev.\nTạo khung project Sau khi đã thiết kế xong giao diện website, chúng ta sẽ bắt đầu xây dựng khung project. Ví dụ cấu trúc thông thường của 1 project web tĩnh:","title":"Code web tĩnh dễ hơn với Pug"},{"content":"Thông thường 1 trang web viết bằng WordPress có thể đẩy lên Internet qua Free Hosting, Share Hosting, VPS, \u0026hellip; Với những ai mới học mà muốn tiết kiệm chi phí thì thường dùng Free Hosting, nhưng Free Hosting thường là host nước ngoài, có rất nhiều hạn chế và hay bị lỗi. Trong bài viết này mình sẽ hướng dẫn các bạn tạo một website WordPress miễn phí trên Heroku và chức năng có thể sử dụng gần như thuê 1 con VPS vậy 😎.\nBước 1 Tạo tài khoản trên https://heroku.com.\nXác nhận tài khoản bằng cách thêm hình thức thanh toán (credit card). Chỉ là thêm hình thức thanh toán chứ không mất phí. Sau khi thêm xong thì sẽ được hưởng thêm rất nhiều quyền lợi và được sử dụng thêm các add-on như database (cần khi cài WordPress). Nếu ai không có Credit Card thì ra ngân hàng đăng ký rất nhanh, nhiều ngân hàng cho phép lấy luôn ngay sau khi đăng ký.\nBước 2 Tạo 1 app mới trong Heroku:\nTải source code WordPress về và giải nén, ta được thư mục wordpress.\nĐẩy source code WordPress lên app vừa tạo bằng Heroku CLI:\nBước 3 Tạo CSDL cho website bằng cách vào tab Resource, phần add-ons và thêm add-on JawsDB Maria (có thể dùng CSDL khác như JawsDB MySQL, \u0026hellip;). Chú ý chỉ có tài khoản đã xác thực (đã thêm Credit Card) thì mới thêm add-ons được:\nSau khi thêm add-on JawsDB Maria thì bấm vào biểu tượng của add-on để chuyển qua trang cấu hình của add-on. Tại đây sẽ có hiển thị thông số để kết nối với CSDL:\nBật website WordPress đã deploy từ trước lên và cài đặt với các thông số kết nối CSDL của add-on JawsDB Maria. Sau đó chúng ta đã có thể tận hưởng thành quả của mình.\nChú ý: Trên Heroku không cho lưu static files nên các themes, plugins hoặc file upload muốn được lưu trữ lại phải nằm trong source code 😅\n","permalink":"https://huydq.dev/blog/tao-website-wordpress-mien-phi-tren-heroku/","summary":"Thông thường 1 trang web viết bằng WordPress có thể đẩy lên Internet qua Free Hosting, Share Hosting, VPS, \u0026hellip; Với những ai mới học mà muốn tiết kiệm chi phí thì thường dùng Free Hosting, nhưng Free Hosting thường là host nước ngoài, có rất nhiều hạn chế và hay bị lỗi. Trong bài viết này mình sẽ hướng dẫn các bạn tạo một website WordPress miễn phí trên Heroku và chức năng có thể sử dụng gần như thuê 1 con VPS vậy 😎.","title":"Tạo website WordPress miễn phí trên Heroku"},{"content":" Có rất nhiều lý do để học về bảo mật web như:\n Bạn lo lắng về việc để lộ thông tin cá nhân trên mạng. Bạn quan tâm đến tính bảo mật cho website hoặc ứng dụng của mình. Bạn là lập trình viên và đang đi xin việc, bạn muốn chuẩn bị sẵn cho trường hợp nhà tuyển dụng hỏi về các vấn đề bảo mật web.  \u0026hellip; và nhiều lý do khác nữa.\nBài viết này sẽ giải thích một vài vấn đề bảo mật web thông dụng kèm theo thuật ngữ chuyên ngành của nó.\n Hai khái niệm cốt lõi trong bảo mật   Không một ai có thể an toàn 100%.\n  Một lớp bảo vệ là không đủ.\n  Cross-Origin Resource Sharing (CORS) Bạn đã bao giờ gặp một thông báo lỗi dạng như này chưa?\nNo \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. Origin \u0026#39;null\u0026#39; is therefore not allowed access. Nếu đã gặp phải lỗi này, bạn sẽ thử tìm giải pháp trên Google. Và bạn sẽ thấy ai đó hướng dẫn cài 1 extension giúp cho lỗi này biến mất và trang web của bạn lại hoạt động bình thường.\nNhưng liệu đây có phải cách làm tốt?\nCORS được sinh ra là để bảo vệ bạn chứ không phải để gây khó khăn cho bạn Trước khi giải thích về CORS, chúng ta hãy cùng tìm hiểu lại về Cookies, đặc biệt là Authentication Cookies. Authentication Cookies được sử dụng để thông báo cho server biết rằng bạn đã đăng nhập vào hệ thống, và chúng được tự động gửi kèm mỗi request lên server.\nGiả sử bạn đã đăng nhập vào Facebook, và họ sử dụng Authentication Cookies.\nSau đó bạn click vào 1 link bất kỳ trên mạng, ví dụ link video full 9 phút và nó sẽ redirect bạn về 1 website nào đó của hacker. Website này sẽ tự động chạy 1 đoạn code Javascript để thực hiện request lên facebook.com có kèm theo authentication cookie của bạn!\nTrong một thế giới không có CORS, hacker có thể thực hiện các thao tác trên Facebook với tài khoản của bạn mà bạn không hề hay biết. Ví dụ như đăng tin lên trên dòng thời gian của bạn kèm theo link video full 9 phút, sau đó bạn bè của bạn click vào link trên và cũng thực hiện hành vi tương tự, \u0026hellip; Vòng lặp này cứ tiếp diễn cho đến khi toàn bộ mạng xã hội facebook đều thấy xuất hiện link video full 9 phút 😆\nThực tế, với sự bảo vệ của CORS, Facebook sẽ chỉ cho phép những request với Origin (đính kèm trong request header) là facebook.com lên server của họ. Tức là chỉ có request thực hiện từ website facebook.com mới được chấp nhận. Hay nói cách khác, họ đã giới hạn việc chia sẻ tài nguyên giữa các tên miền khác nhau (cross-origin resource sharing).\nBạn cũng có thể tự hỏi:\n- \u0026ldquo;Vậy nếu website của hacker cố tình thay đổi header origin khi gửi request thì sao?\u0026rdquo;. Đúng, họ có thể làm như vậy. Nhưng trình duyệt sẽ tự động bỏ qua và chỉ gửi lên origin thực sự (là tên miền của website thực hiện request).\n- \u0026ldquo;Vậy nếu request được thực hiện từ phía server chứ không phải client?\u0026rdquo;. Trong trường hợp này hacker có thể vượt qua được CORS nhưng họ lại không thể gửi kèm được authentication cookie bởi vì nó nằm ở phía client.\nContent Security Policy (CSP) Để hiểu về CSP (chính sách bảo mật nội dung), trước tiên chúng ta cần tìm hiểu về một lỗ hổng rất thông dụng trên web, đó là XSS ( cross- s ite s cripting, ký hiệu X thay cho C để tránh nhầm lẫn với CSS 😀). XSS là khi kẻ xấu nhúng code Javascript vào trong code phía client của bạn.\nBạn có thể nghĩ rằng: \u0026ldquo;Nhúng code Javascript vào thì làm được gì? Thay đổi màu chữ từ đỏ sang xanh? \u0026hellip;\u0026rdquo;\nGiả sử một ai đó nhúng được code Javascript vào website mà bạn đang truy cập. Khi đó họ có thể:\n Giả dạng bạn để thực hiện một HTTP request. Nhúng 1 iframe trông như 1 phần website và yêu cầu bạn nhập mật khẩu rồi gửi request đến server của hacker. Chèn hoặc sửa một đường dẫn trên website gốc, dẫn đến một website giả mạo với giao diện giống hệt website gốc để thực hiện hành vi lừa đảo (ví dụ yêu cầu đăng nhập, yêu cầu nhập thông tin tài khoản, \u0026hellip;)  \u0026hellip; và muôn vàn khả năng khác.\nCSP sẽ cố gắng ngăn chặn điều này ngay từ đầu bằng cách giới hạn:\n Cái gì có thể được phép mở trong một iframe. Style nào có thể được tải. Request có thể được thực hiện ở đâu. \u0026hellip;  Vậy nó hoạt động như nào? Khi bạn bấm vào một đường link hoặc gõ địa chỉ website trên trình duyệt thì trình duyệt sẽ thực hiện một GET request. Và server sẽ trả về HTML kèm theo một vài HTTP headers. Nếu bạn muốn biết mình nhận được header như nào thì hãy bật tab Network trong DevTools và truy cập thử một website. Bạn có thể sẽ thấy một response header như sau:\ncontent-security-policy: default-src * data: blob:; script-src *.facebook.com *.fbcdn.net *.facebook.net *.google-analytics.com *.virtualearth.net *.google.com 127.0.0.1:* *.spotilocal.com:* \u0026#39;unsafe-inline\u0026#39; \u0026#39;unsafe-eval\u0026#39; *.atlassolutions.com blob: data: \u0026#39;self\u0026#39;; style-src data: blob: \u0026#39;unsafe-inline\u0026#39; *; connect-src *.facebook.com facebook.com *.fbcdn.net *.facebook.net *.spotilocal.com:* wss://*.facebook.com:* https://fb.scanandcleanlocal.com:* *.atlassolutions.com attachment.fbsbx.com ws://localhost:* blob: *.cdninstagram.com \u0026#39;self\u0026#39; chrome-extension://boadgeojelhgndaghljhdicfkmllpafd chrome-extension://dliochdbjfkdbacpmhlcpmleaejidimm; Đó là chính sách bảo mật nội dung của Facebook. Tìm hiểu chi tiết hơn các directives (chỉ thị):\n  default-src: Hạn chế tất cả các CSP directive mà không được liệt kê rõ ràng.\n  script-src: Giới hạn những script có thể được load.\n  style-src: Giới hạn những style có thể được load.\n  connect-src: Giới hạn những URL nào có thể được load sử dụng script như fetch, XHR, ajax, \u0026hellip;\n  Có nhiều CSP directive khác nữa ngoài 4 cái ở trên. Trình duyệt sẽ đọc CSP header và áp dụng toàn bộ những directive đó cho mọi thứ trên trang HTML.\nHTTPS hay HTTP Secure Chắc chắn bạn đã từng nghe nói đến HTTPS. Có thể bạn nghe nói rằng Chrome sẽ đánh dấu trang web của bạn là không an toàn (insecure) nếu nó không có HTTPS.\nVề bản chất thì HTTPS khá đơn giản. HTTPS thì được mã hóa còn HTTP thì không.\nVậy cái này thì có liên quan gì nếu như bạn không gửi những dữ liệu nhạy cảm? Hãy cùng tìm hiểu thêm về một thuật ngữ khác: MITM ( M an i n t he M iddle).\nNếu bạn đang sử dụng Wi-Fi công cộng (không đặt mật khẩu) ở một quán cà phê, một ai đó có thể dễ dàng bắt được request của bạn. Nếu dữ liệu của bạn không được mã hóa, họ có thể đọc được làm bất cứ thứ gì họ muốn. Họ có thể chỉnh sửa HTML, CSS hoặc Javascript trước khi trình duyệt của bạn nhận được dữ liệu. Tương tự như XSS ở trên, bạn có thể hình dung được hacker có thể làm được những gì.\nSử dụng HTTPS thì mọi dữ liệu truyền và nhận giữa máy tính của bạn và server đều được mã hóa khiến cho hacker không thể đọc hay chỉnh sửa tùy ý được.\nHTTP Strict-Transport-Security (HSTS) Tiếp tục sử dụng Facebook header làm ví dụ:\nstrict-transport-security: max-age=15552000; preload Header trên chỉ áp dụng nếu bạn truy cập trang sử dụng HTTPS:\n max-age: Chỉ định thời gian trình duyệt ghi nhớ để bắt buộc người dùng truy cập website bằng HTTPS. preload: Không quan trọng lắm với mục đích của chúng ta, nó là một dịch vụ được host bởi Google.  Giả sử bạn truy cập trang Facebook lần đầu tiên và bạn biết HTTPS an toàn hơn HTTP nên bạn truy cập qua HTTPS. Khi trình duyệt nhận được header trên nó sẽ ghi nhớ chuyển hướng những request sau này của bạn về HTTPS. Một tháng sau có ai đó gửi cho bạn một link đến Facebook sử dụng HTTP và bạn bấm vào nó. Do 1 tháng thì nhỏ hơn 15552000 giây (giá trị của max-age) nên trình duyệt sẽ gửi request dưới dạng HTTPS để tránh tấn công MITM.\nTổng kết Bảo mật web rất quan trọng bất kể bạn làm ở vị trí nào trong mảng phát triển web. Bạn càng tiếp xúc, càng tìm hiểu nó kỹ hơn thì bạn càng có lợi.\nBảo mật nên là thứ quan trọng với tất cả mọi người chứ không chỉ riêng những chuyên gia bảo mật 👮.\nNguồn: https://medium.freecodecamp.org/a-quick-introduction-to-web-security-f90beaf4dd41\n","permalink":"https://huydq.dev/blog/co-ban-ve-bao-mat-web/","summary":"Có rất nhiều lý do để học về bảo mật web như:\n Bạn lo lắng về việc để lộ thông tin cá nhân trên mạng. Bạn quan tâm đến tính bảo mật cho website hoặc ứng dụng của mình. Bạn là lập trình viên và đang đi xin việc, bạn muốn chuẩn bị sẵn cho trường hợp nhà tuyển dụng hỏi về các vấn đề bảo mật web.  \u0026hellip; và nhiều lý do khác nữa.","title":"Cơ bản về bảo mật Web"},{"content":"Để quản lý Dependencies (packages) trong Go chúng ta có thể dùng nhiều tool hỗ trợ. Về bản chất thì chúng tương tự nhau nhưng cũng có nhưng ưu nhược điểm riêng, ví dụ một số tool mình đã từng sử dụng như Dep hoặc Glide (tham khảo bài viết Quản lý package trong Go).\nHiện mình đang sử dụng một tool khác là Govendor, và theo ý kiến cá nhân thì mình thấy tool này dễ sử dụng hơn, và cách cấu hình cũng như hoạt động của nó khá giống với npm trên NodeJS. Do đó sẽ dễ tiếp cận hơn đối với các lập trình viên NodeJS hoặc Javascript nói chung.\nDưới đây là một số hướng dẫn cơ bản để sử dụng Govendor.\nCài đặt Dùng Go get để cài như các package khác:\ngo get -u github.com/kardianos/govendor Chú ý project vẫn phải nằm trong $GOPATH/src.\nSử dụng Khởi tạo Govendor (trong thư mục chứa source code của project):\ngovendor init Lệnh này sẽ tạo thêm thư mục vendor trong project, và trong thư mục này có 1 file để cấu hình dependencies là vendor.json.\nCài đặt dependencies (ví dụ github.com/jinzhu/gorm):\ngovendor fetch github.com/jinzhu/gorm _Lệnh trên sẽ tạo mới (hoặc update) gói github.com/jinzhu/gorm (lưu vào trong thư mục vendor)._\nTrong trường hợp cần chỉ định rõ version của dependency thì ta dùng lệnh sau:\n// Lấy version mới nhất bắt đầu với tên v1 govendor fetch github.com/jinzhu/gorm@v1  // Lấy chính xác version v1.9 govendor fetch github.com/jinzhu/gorm@=v1.9 Hoặc chúng ta có thể sửa file vendor.json, bổ sung thêm trường \u0026ldquo;version\u0026rdquo; và \u0026ldquo;versionExact\u0026rdquo;:\n{ \u0026#34;checksumSHA1\u0026#34;: \u0026#34;qUfWkFlJqc24xFWAsWxKkyyO+zw=\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;github.com/jinzhu/gorm\u0026#34;, \u0026#34;revision\u0026#34;: \u0026#34;742154be9a26e849f02d296073c077e0a7c23828\u0026#34;, \u0026#34;revisionTime\u0026#34;: \u0026#34;2018-10-07T00:49:37Z\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;v1\u0026#34;, \u0026#34;versionExact\u0026#34;: \u0026#34;v1.9.1\u0026#34; }, Để xóa dependency ta dùng lệnh remove:\ngovendor remove github.com/jinzhu/gorm Kiểm tra lại các dependencies trong project:\ngovendor list   Ví dụ hiển thị trên terminal   Chú ý ký tự v ở trước là trạng thái của package. Trạng thái của package có thể là vendor (v), external (e), \u0026hellip; tham khảo chi tiết trên github.\nTip Khi quản lý source code (ví dụ dùng Git), chúng ta sẽ commit cả thư mục vendor lên. Như vậy khi người khác pull source code về sẽ không cần cài lại dependencies nữa. Đặc biệt khi deploy code dùng Docker thì ở bước build chúng ta cũng không cần lấy dependencies qua mạng.\nMột cách khác đó là không lưu thư mục vendor vào trong source code (để giảm bớt dung lượng), thì chúng ta chỉ cần lưu file vendor.json(tương tự package.json khi sử dụng npm). Sau đó khi pull code về thì cài lại dependencies bằng lệnh govendor sync.\n","permalink":"https://huydq.dev/blog/quan-ly-dependencies-trong-go-bang-govendor/","summary":"Để quản lý Dependencies (packages) trong Go chúng ta có thể dùng nhiều tool hỗ trợ. Về bản chất thì chúng tương tự nhau nhưng cũng có nhưng ưu nhược điểm riêng, ví dụ một số tool mình đã từng sử dụng như Dep hoặc Glide (tham khảo bài viết Quản lý package trong Go).\nHiện mình đang sử dụng một tool khác là Govendor, và theo ý kiến cá nhân thì mình thấy tool này dễ sử dụng hơn, và cách cấu hình cũng như hoạt động của nó khá giống với npm trên NodeJS.","title":"Quản lý Dependencies trong Go bằng Govendor"},{"content":"Tôi vừa trở về sau một chuyến du lịch 2 tuần đến Nhật Bản.\nMột trong những hình ảnh quen thuộc ở đây đó là số lượng lớn các cửa hàng cà phê Starbucks, đặc biệt là quanh khu vực Shinjuku và Roppongi. Trong khi chờ đợi một tách ca cao nóng, tôi đã nghĩ về cách thức mà Starbucks phục vụ khách hàng.\nStarbucks cũng như hầu hết các công ty khác thì đều muốn tối đa số lượng khách hàng có thể phục vụ. Càng đông khách thì lợi nhuận càng cao. Do đó họ đã sử dụng quy trình bất đồng bộ (asynchronous processing).\nKhi bạn yêu cầu đồ uống, nhân viên thu ngân sẽ đánh dấu một chiếc cốc với đơn hàng của bạn và đưa nó vào một hàng đợi (queue). Hàng đợi chỉ đơn giản là một dãy những chiếc cốc xếp hàng và chuyển sang cho thợ pha cà phê. Bằng cách này, nhân viên thu ngân sẽ có thể tiếp tục nhận thêm đơn hàng kể cả khi đơn hàng cũ chưa xử lý xong. Trong trường hợp cửa hàng quá đông khách, họ có thể áp dụng kịch bản Competing Consumer để phục vụ khách tốt hơn: Vẫn chỉ một nhân viên thu ngân nhưng thuê nhiều nhân viên pha cà phê.\nCorrelation problem Giải quyết vấn đề theo cách bất đồng bộ mang lại cho Starbucks nhiều lợi ích, tuy nhiên đi kèm với nó cũng có khá nhiều vấn đề cần giải quyết.\nVí dụ về vấn đề liên hệ (correlation problem) như đồ uống không hoàn thành theo đúng thứ tự như khi khách hàng yêu cầu. Điều này có thể xảy ra khi:\n Các nhân viên pha cà phê khi pha chế sử dụng các công cụ khác nhau. Pha chế đồ uống hỗn hợp có thể lâu hơn là cà phê. Nhân viên pha cà phê cũng có thể thực hiện cùng một lúc các công việc giống nhau trước để tối ưu thời gian pha chế.  Kết quả là đồ uống khi pha chế xong sẽ được mang ra cho khách không theo thứ tự và cần phải mang đến đúng vị khách đã yêu cầu đồ uống.\nStarbucks giải quyết vấn đề này theo một pattern được sử dụng trong kiến trúc messaging: Correlation Identifier. Ở Mỹ, hầu hết các cửa hàng Starbucks sẽ xử lý vấn đề này bằng cách viết tên bạn lên cốc và gọi lên khi đồ uống hoàn thành. Ở những quốc gia khác, bạn sẽ phải liên hệ bằng loại đồ uống (ví dụ như nâu đá, americano, \u0026hellip;).\nException Handling Xử lý ngoại lệ (exception handling) trong môi trường asynchronous messaging có thể khá là khó. Hãy cùng xem Starbucks giải quyết các trường hợp ngoại lệ như nào.\n Khi khách hàng không thể trả tiền, họ sẽ vứt bỏ đồ uống nếu nó đã được pha chế hoặc nếu không thì họ sẽ loại bỏ nó ra khỏi hàng đợi. Nếu họ mang cho khách hàng một đồ uống không phù hợp hay có vấn đề thì họ sẽ làm lại nó. Nếu như máy pha cà phê bị hỏng và họ không thể pha chế được đồ uống thì họ sẽ trả lại tiền cho khách hàng..  Mỗi một ví dụ trên miêu tả cho một cách xử lý ngoại lệ phổ biến:\n Write-off: Cách đơn giản nhất đó là không làm gì hoặc loại bỏ hết những cái vừa làm. Nghe có vẻ không phải là một cách hay, tuy nhiên trong thực tế thì lựa chọn này có thể chấp nhận được. Nếu như mất mát là nhỏ thì việc xây dựng một giải pháp xử lý ngoại lệ còn tốn kém hơn là bỏ qua nó. Ví dụ như tôi đã từng làm việc cho một số nhà cung cấp dịch vụ Internet mà áp dụng cách giải quyết này cho các lỗi xảy ra ở chu trình thanh toán và cung cấp dịch vụ. Một số khách hàng có thể sử dụng dịch vụ khi chưa thực hiện xong thanh toán. Doanh thu mất đi đủ nhỏ để cho phép nghiệp vụ vận hành bình thường và cứ sau một khoảng thời gian định kỳ họ sẽ thống kê lại những tài khoản chưa thực hiện thanh toán để ngắt dịch vụ. Retry: Khi có một số hành động trong một nhóm các hành động (ví dụ transaction) bị thất bại, chúng ta sẽ có 2 lựa chọn là undo những cái thành công hoặc retry những cái thất bại. Retry (thực hiện lại hành động) là một lựa chọn tốt nếu như có khả năng retry thành công. Ví dụ như xung đột nghiệp vụ thì retry có thể sẽ không thành công nhưng nếu là do một hệ thống bên ngoài tạm thời không đáp ứng thì retry có thể thành công. Một ví dụ điển hình là Idempotent Receiver, trong trường hợp này chúng ta có thể đơn giản retry lại tất cả hành động vì receivers thành công sẽ bỏ qua các message trùng lặp. Compensating Action: Lựa chọn cuối cùng đó là undo lại những hành động đã hoàn thành để đưa hệ thống trở lại trạng thái trước đó. Cách này sẽ hoạt động tốt trong các hệ thống tài chính, chúng ta có thể cộng bù lại những khoản tiền đã bị trừ đi trước đó.  Tất cả các cách giải quyết trên đều khác với phương pháp Two-phase commit mà dựa trên các bước riêng biệt là prepare và execute. Trong ví dụ của Starbucks, Two-phase commit tương đương với việc khách hàng chờ ở quầy thanh toán cho đến khi đồ uống được pha chế xong, sau đó khách hàng trả tiền và nhận đồ uống + biên lai thanh toán. Cả nhân viên thu ngân lẫn khách hàng đều không thể rời đi cho đến khi giao dịch hoàn tất. Sử dụng Two-phase commit có thể khiến Starbucks phá sản bởi vì số lượng khách hàng mà họ có thể phục vụ trong một khoảng thời gian là quá thấp.\nCần chú ý rằng Two-phase commit có thể làm ảnh hưởng đến cách hoạt động tự do của message (và cả khả năng mở rộng) bởi vì nó phải duy trì trạng thái của các tài nguyên trong giao dịch qua các hành động bất đồng bộ.\nConversations Sự tương tác trong quán cà phê là một ví dụ tốt của một pattern đơn giản nhưng phổ biến: Conversation pattern.\nSự tương tác giữa hai bên (quán cà phê và khách hàng) có chứa một tương tác ngắn đồng bộ (gọi nước và trả tiền) và một tương tác dài bất đồng bộ (pha chế và nhận đồ uống). Loại tương tác này khá bổ biến trong các kịch bản mua bán.\nVí dụ khi đặt một đơn hàng trên Amazon, tương tác ngắn đồng bộ gán một mã đơn hàng và tất cả các bước tiếp theo (trừ tiền trong thẻ, đóng gói hàng, vận chuyển, \u0026hellip;) thì được thực hiện bất đồng bộ. Bạn được thông báo qua email khi các bước bổ sung hoàn thành. Nếu có bất kỳ vấn đề sai nào xảy ra, Amazon thường sẽ bồi thường (qua credit card) hoặc thử lại (gửi lại các sản phẩm bị mất).\nTóm lại chúng ta có thể thấy rằng thế giới thực thường là bất đồng bộ. Cuộc sống hàng ngày của chúng ta có nhiều tương tác bất đồng bộ. Nó có nghĩa là kiến trúc truyền tin bất đồng bộ có thể là một cách tự nhiên để thực thể hóa những tương tác này. Nó cũng có nghĩa là chúng ta nhìn vào các ví dụ trong cuộc sống hàng ngày để thiết kế ra những giải pháp hợp lý.\nDomo arigato gozaimasu! (xin cảm ơn rất nhiều)\nBài viết được dịch từ một chương trong sách The best software writting I , tác giả Gregor Hohpe.\n","permalink":"https://huydq.dev/blog/starbucks-khong-su-dung-two-phase-commit/","summary":"Tôi vừa trở về sau một chuyến du lịch 2 tuần đến Nhật Bản.\nMột trong những hình ảnh quen thuộc ở đây đó là số lượng lớn các cửa hàng cà phê Starbucks, đặc biệt là quanh khu vực Shinjuku và Roppongi. Trong khi chờ đợi một tách ca cao nóng, tôi đã nghĩ về cách thức mà Starbucks phục vụ khách hàng.\nStarbucks cũng như hầu hết các công ty khác thì đều muốn tối đa số lượng khách hàng có thể phục vụ.","title":"Starbucks không sử dụng Two-Phase Commit"},{"content":"Một Database Transaction, theo như định nghĩa sẽ phải thỏa mãn các tính chất sau: Atomic, Consistency, Isolation và Durable (hay thường được gọi là ACID). Bài viết này sẽ tập trung vào tính chất Consistency (tính nhất quán), và so sánh giữa Eventual Consistency với Strong Consistency trong hệ thống Distributed Databases qua các ví dụ đời thường.\nLý thuyết Distributed Database (hệ thống cơ sở dữ liệu phân tán): Là hệ thống Cơ sở dữ liệu (CSDL) mà có thể được phân tải, lưu trữ ở nhiều nơi. Ví dụ như ứng dụng sử dụng nhiều CSDL và các CSDL có thể nằm ở các máy chủ vật lý khác nhau.\nStrong Consistency (tính nhất quán mạnh): Sau khi một cập nhật được diễn ra thì tất cả các lần đọc dữ liệu sau đó đều trả về giá trị mới được cập nhật.\nEventual Consistency (tính nhất quán cuối cùng, là một dạng của tính nhất quán yếu - Weak Consistency): Sau khi một cập nhật được diễn ra, các lần đọc sau đó không đảm bảo sẽ luôn trả về giá trị mới được cập nhật (có thể có lần đọc vẫn trả về dữ liệu cũ). Tuy nhiên sau một khoảng thời gian (đồng bộ giữa các CSDL) thì cuối cùng các lần đọc đều trả về giá trị mới nhất.\nVí dụ đời thường Một anh chàng tên Duy, có sở thích sưu tập phim và toàn bộ những bộ phim anh ta tải được trên mạng đều được lưu vào laptop. Laptop ở đây đóng vai trò như một CSDL.\nDo sợ vào một ngày đẹp trời laptop bị ăn trộm hoặc bị hỏng sẽ làm mất hết toàn bộ phim trong máy nên Duy mua thêm một ổ cứng di động 8TB và một tài khoản Dropbox để sao lưu lại toàn bộ dữ liệu cho an toàn. Lúc này Laptop, ổ cứng di động và tài khoản Dropbox được coi như một hệ CSDL phân tán (theo mô hình Master - Slave).\n1. Eventual Consistency Khi sử dụng nhiều replica (bản sao) cho một CSDL, giả sử có một write request đến một replica (insert, update, delete dữ liệu) thì chúng ta phải làm sao cho các replica còn lại cũng nhận được request tương ứng để đồng bộ dữ liệu.\nViệc đồng bộ dữ liệu này sẽ tốn thời gian (có thể rất nhỏ), nhưng trong khoảng thời gian đó, nếu có một read request đến một replica chưa đồng bộ xong thì request đó sẽ nhận được kết quả cũ hơn (stale data).\nQuay lại ví dụ của Duy:\n  Cứ mỗi tuần vào tối Thứ Sáu Duy sẽ đồng bộ dữ liệu trong laptop với ổ cứng di động.\n  Tối Chủ Nhật, Long là bạn của Duy mượn ổ cứng di động của Duy để xem phim. Lúc này Long có thể lấy luôn ổ cứng mang về và có toàn bộ dữ liệu cho đến lần sao lưu gần nhất (tức là nếu Thứ Bảy hoặc sáng Chủ Nhật Duy download thêm phim thì trong ổ cứng sẽ không có).\n  Sáng Thứ Hai tuần sau, Long trả lại ổ cứng cho Duy và đến tối Chủ Nhật lại mượn tiếp. Thời điểm đó Long sẽ lại có được toàn bộ phim (bao gồm cả những phim chưa kịp đồng bộ trong tuần này).\n  2. Strong Consistency Tương tự như Eventual Consistency, tuy nhiên để đảm bảo tính nhất quán thì trong trường hợp Strong Consistency toàn bộ các replica sẽ bị delay (trạng thái bận) cho đến khi quá trình đồng bộ hoàn tất.\nChỉ đến khi dữ liệu giữa các replica đã nhất quán thì chúng ta mới trả về kết quả cho client, do đó nó sẽ đảm bảo mọi read request đến sau luôn lấy được dữ liệu mới nhất (nhưng thời gian trả về kết quả lâu hơn).\nQuay lại ví dụ của Duy:\n  Cứ mỗi tuần vào tối Thứ Bảy Duy sẽ đồng bộ dữ liệu trong laptop Dropbox.\n  Tối Chủ Nhật, Dương cũng là bạn của Duy xin link Dropbox để tải phim. Lúc này Duy bảo: \u0026ldquo;Tôi đã share cho ông link qua Slack rồi nhé, nhưng để mai hãy down thì sẽ có phim mới nhất tôi vừa down sáng nay\u0026rdquo;.\n  Như vậy để có phim mới nhất xem thì Dương sẽ phải chờ một thời gian khá dài để Duy đồng bộ phim lên Dropbox. Thời gian nhanh hay chậm còn tùy thuộc vào dung lượng phim, tốc độ internet, \u0026hellip;\n  3. Kết luận Strong Consistency cho phép dữ liệu luôn nhất quán và được cập nhật mới nhất, nhưng nó có độ trễ cao.\nEventual Consistency thì có độ trễ thấp, kết quả trả về nhanh nhưng dữ liệu nhận được có thể không phải mới nhất.\n=\u0026gt; Do đó việc thiết kế CSDL hay sử dụng thuộc tính nhất quán nào sẽ tùy vào yêu cầu của từng project cụ thể.\nTham khảo bài viết gốc Eventual vs Strong Consistency in Distributed Databases.\n","permalink":"https://huydq.dev/blog/eventual-consistency-va-strong-consistency-trong-he-thong-co-so-du-lieu-phan-tan/","summary":"Một Database Transaction, theo như định nghĩa sẽ phải thỏa mãn các tính chất sau: Atomic, Consistency, Isolation và Durable (hay thường được gọi là ACID). Bài viết này sẽ tập trung vào tính chất Consistency (tính nhất quán), và so sánh giữa Eventual Consistency với Strong Consistency trong hệ thống Distributed Databases qua các ví dụ đời thường.\nLý thuyết Distributed Database (hệ thống cơ sở dữ liệu phân tán): Là hệ thống Cơ sở dữ liệu (CSDL) mà có thể được phân tải, lưu trữ ở nhiều nơi.","title":"Eventual Consistency và Strong Consistency trong hệ thống Cơ sở dữ liệu phân tán"},{"content":"Bài viết được dịch (có chỉnh sửa) từ cuốn Patterns Principles and Practices of Domain Driven Design của Scott Millett và Nick Tune, dành cho những ai đã và đang cần tìm hiểu về CQRS (Command Query Responsibility Segregation). Trong bài viết có sử dụng nhiều thuật ngữ chuyên ngành, mình sẽ dẫn link đến các tài liệu Tiếng Anh tương ứng chứ không dịch (không biết dịch như nào hoặc dịch ra nghe rất củ chuối 😬).\n1. CQRS rất khó Xét về mức cơ bản thì CQRS chỉ là một pattern đơn giản triển khai nguyên tắc Single Responsibility Principle (SRP) ở lớp Domain Model.\nCQRS không phải là một framework hay là một hệ thống multiple database, nó là pattern được áp dụng vào bounded context, dùng để chia Domain Model thành 2 model: Write Model (Command side) và Read Model (Query side), chúng được xử lý riêng rẽ để đạt hiệu quả tốt hơn.\nCQRS thiên về khái niệm, tư tưởng hơn là một tập hợp các nguyên tắc và pattern phức tạp mà bạn phải tuân theo.\n2. CQRS là Eventually Consistent Eventually Consistency được áp dụng để Read Model được cập nhật bất đồng bộ (asynchronous) với Write Model (sẽ có một bài viết khác giải thích chi tiết hơn về Eventually Consistency).\nĐây không phải là điều kiện tiên quyết của CQRS, nhưng nó thường được sử dụng để cho phép bên Read side có thể scale (mở rộng) dễ dàng.\nCQRS không yêu cầu bạn phải thực hiện Eventually Consistent. Bạn có thể sử dụng cùng một database và transaction để cập nhật Read Model hoặc sử dụng caching để có Strong Consistency.\n3. Model phải dùng Event Sourcing Event Sourcing là một cách rất hiệu quả để xây dựng cả Read Model và Write Model nhưng nó không bắt buộc phải có khi sử dụng CQRS.\nEvent Sourcing là một giải pháp lưu trữ dữ liệu theo lịch sử một cách chính xác, nhưng nó cũng giúp xây dựng Read Model dễ dàng hơn bởi vì bạn có thể tạo ra bất kỳ projection mong muốn từ những dữ liệu sự kiện theo lịch sử.\n4. Command nên là Asynchronous CQRS không bắt buộc Command phải được gửi theo kiểu fire-and-forget (không quan tâm đến response).\nVới các trường hợp tương tác cao, nhiều user thực hiện thay đổi vào cùng dữ liệu thì Asynchronous Command sẽ hiệu quả. Nó sẽ giúp ứng dụng dễ scale và không bị quá tải.\nTuy nhiên các Command mà không phản hồi lại thành công hay thất bại sẽ cần phải có những cách khác để cập nhật cho user kết quả của hành động. Nó có thể là qua email hoặc qua các thao tác phụ xử lý message lỗi.\n5. CQRS chỉ hoạt động được với hệ thống Messaging Nếu bạn đang tìm cách áp dụng một Read store theo cách eventually consistent hoặc xử lý Command theo kiểu bất đồng bộ thì dùng một messaging framework có thể là một ý tưởng tốt.\nNgược lại, sử dụng một hệ thống messaging khi không cần thiết sẽ làm cho ứng dụng của bạn trở nên phức tạp và khó bảo trì hơn.\n6. Cần phải sử dụng Domain Event với CQRS Sử dụng Event để dựng Read Model là một phương pháp hiệu quả để giữ Read Model và Write Model được tách biệt.\nTuy nhiên nó không phải là cách duy nhất, và bạn có thể sử dụng nhiều method khác để tạo Read store, ví dụ như dựng trực tiếp từ dữ liệu quan hệ của Write Model.\nHy vọng những chú ý trên đây sẽ giúp các bạn xây dựng hệ thống sử dụng CQRS một cách chính xác hơn, phù hợp với yêu cầu của ứng dụng.\n","permalink":"https://huydq.dev/blog/nhung-quan-niem-sai-lam-ve-cqrs/","summary":"Bài viết được dịch (có chỉnh sửa) từ cuốn Patterns Principles and Practices of Domain Driven Design của Scott Millett và Nick Tune, dành cho những ai đã và đang cần tìm hiểu về CQRS (Command Query Responsibility Segregation). Trong bài viết có sử dụng nhiều thuật ngữ chuyên ngành, mình sẽ dẫn link đến các tài liệu Tiếng Anh tương ứng chứ không dịch (không biết dịch như nào hoặc dịch ra nghe rất củ chuối 😬).","title":"Những quan niệm sai lầm về CQRS"},{"content":"Chắc hẳn các lập trình viên, đặc biệt là các Backend developer, sẽ không còn xa lạ với Cookie (thường đi kèm với Session). Tuy nhiên nhiều người có thể chưa thực sự hiểu rõ vì nó thường hay được giới thiệu kèm với một ngôn ngữ lập trình phía Backend (ví dụ như PHP, NodeJS, \u0026hellip;) và sử dụng các các thư viện để thao tác. Bài viết này sẽ giới thiệu rõ ràng hơn về Cookie cả phía Backend lẫn Frontend và một số vấn đề bảo mật liên quan đến Cookie để các web developer thận trọng hơn khi sử dụng.\nCookie là gì? Cookie (tên đầy đủ HTTP Cookies) là một file text nhỏ được lưu trữ bởi trình duyệt (browser) ở trên máy người dùng (client). Nó thường được sử dụng với 3 mục đích chính:\n Quản lý phiên làm việc (Session management). Cá nhân hóa thông tin người dùng (Personalization). Theo dõi, phân tích hành vi người dùng (Tracking).  Ví dụ với trường hợp Quản lý phiên làm việc:\n  User truy cập một trang trong website (thực hiện 1 request lên server), web server yêu cầu trình duyệt lưu thông tin truy cập của user vào Cookie. Sau đó, mỗi khi user thực hiện một request khác vẫn website đó thì trình duyệt lại gửi thông tin đã lưu trong Cookie lên. Nhờ đó web server có thể biết được các request là đến từ cùng 1 User. Nếu bạn sử dụng 2 trình duyệt khác nhau trên cùng một máy thì server sẽ hiểu các request là đến từ 2 người vì các trình duyệt khác nhau lưu Cookies khác nhau.   Thông tin lưu trữ trong cookie có thể trong một thời gian dài hoặc chỉ trong một phiên làm việc tùy vào cách cấu hình Cookies. Thông thường ta hay sử dụng Session Cookies để lưu trạng thái của phiên làm việc (SessionID), thông tin sẽ bị xóa khi hết phiên làm việc (khi người dùng tắt trình duyệt).\n  Cách tạo ra Cookie Cookie có thể được tạo ra từ phía Server hoặc Client. Khi nhận được một HTTP request, nếu muốn tạo Cookie từ server, ta sẽ trả responve về cho trình duyệt một HTTP Header với tên là Set-Cookie, giá trị là các dữ liệu cần lưu vào Cookie (theo dạng key=value) và các tùy chọn như: Loại Cookies, thời gian sống, \u0026hellip; Ví dụ tạo một Cookies đơn giản:\nSet-Cookie: sid=techmaster Khi trình duyệt thực hiện các request khác, nó sẽ gửi kèm dữ liệu trong Cookies trở lại server cũng qua HTTP Header với tên là Cookie:\nCookie: sid=techmaster; Cookies cũng có thể được tạo, chỉnh sửa từ phía Client thông qua Javascript bằng cách sử dụng document.cookie. Cú pháp tương tự như tạo Cookies từ phía server:\ndocument.cookie = \u0026#34;sid=techmaster;\u0026#34;; Để lấy ra giá trị của Cookies ta cũng chỉ cần gọi document.cookie.\nBảo mật Cookies Do Cookies thường được sử dụng để quản lý trạng thái của người dùng (ví dụ trạng thái đăng nhập), do đó có thể có một số vấn đề liên quan đến bảo mật khi sử dụng Cookies. Ví dụ như Cookies lưu trạng thái đăng nhập của người dùng bị đánh cắp, hacker có thể dùng Cookies này để giả mạo làm người dùng và thực hiện tương tác với trang web mà không cần đăng nhập. Một số extension của trình duyệt cho phép share Cookies để những người dùng khác nhau cùng truy cập vào 1 tài khoản mà không cần biết thông tin truy cập như username và password.\nĐể bảo mật Cookies hơn thì khi tạo Cookies ta sẽ cần sử dụng thêm một số options như domain, path, \u0026hellip; dùng để giới hạn việc gửi Cookies chỉ cho phép theo domain và đường dẫn thiết lập trước. Ví dụ:\nSet-Cookie: sid=techmaster; domain=techmaster.vn; path=/auth Với các website hỗ trợ https thì ta thêm thuộc tính secure để đảm bảo việc gửi Cookies sẽ chỉ qua SSL, giao thức https:\nSet-Cookie: sid=techmaster; domain=techmaster.vn; path=/auth; secure Với các dữ liệu cần bảo mật hơn (ví dụ như SessionID) thì ta sẽ chỉ thiết lập từ phía server và bổ sung thêm options HttpOnly để không cho phép truy cập dữ liệu này thông qua Javascript (document.cookie). Ví dụ:\nSet-Cookie: sid=techmaster; domain=techmaster.vn; path=/auth; secure; HttpOnly ","permalink":"https://huydq.dev/blog/cookies-va-van-de-bao-mat/","summary":"Chắc hẳn các lập trình viên, đặc biệt là các Backend developer, sẽ không còn xa lạ với Cookie (thường đi kèm với Session). Tuy nhiên nhiều người có thể chưa thực sự hiểu rõ vì nó thường hay được giới thiệu kèm với một ngôn ngữ lập trình phía Backend (ví dụ như PHP, NodeJS, \u0026hellip;) và sử dụng các các thư viện để thao tác. Bài viết này sẽ giới thiệu rõ ràng hơn về Cookie cả phía Backend lẫn Frontend và một số vấn đề bảo mật liên quan đến Cookie để các web developer thận trọng hơn khi sử dụng.","title":"Cookies và vấn đề bảo mật"},{"content":"Trong các ứng dụng cho phép người dùng nhập dữ liệu thì đều cần phải có validate để bảo mật và đảm bảo ứng dụng chạy đúng.\nGolang có một số thư viện open source hỗ trợ chúng ta làm việc này một cách nhanh chóng, ví dụ như govalidator.\nCài đặt Cài govalidator qua package manager hoặc đơn giản là dùng go get:\ngo get github.com/asaskevich/govalidator Import vào trong project:\nimport validator \u0026#34;github.com/asaskevich/govalidator\u0026#34; Sử dụng Govalidator cung cấp rất nhiều function hỗ trợ chúng ta validate dữ liệu theo các dạng thông dụng như: URL, Email, Alpha, Numeric Alphanumeric, Regex, \u0026hellip; Danh sách các hàm hỗ trợ: https://github.com/asaskevich/govalidator#list-of-functions\nNgoài ra Govalidator còn hỗ trợ chúng ta validate struct (kiểm tra tính hợp lệ của các field trong struct) bằng cách sử dụng tag valid. Ví dụ:\ntype User struct { \tId int `valid:\u0026#34;required\u0026#34;` \tName string `valid:\u0026#34;required\u0026#34;` \tEmail string `valid:\u0026#34;email\u0026#34;` \tPassword string `valid:\u0026#34;required\u0026#34;` } Sau khi khai báo Struct xong, để kiểm tra toàn bộ struct ta gọi hàm ValidateStruct():\nuser := User{  Id: 1, \tName: \u0026#34;\u0026#34;, \tPhone: \u0026#34;1080\u0026#34;, \tEmail: \u0026#34;fake_email\u0026#34;, \tPassword: \u0026#34;secret\u0026#34;, }  if ok, err := govalidator.ValidateStruct(user); err != nil { \tfmt.Print(err) // In ra các thông báo lỗi } else { \tfmt.Print(\u0026#34;Struct hợp lệ\u0026#34;) } Tiptrick Nếu trong Struct có nhiều trường cần require thì ta có thể cấu hình mặc định các field là require:\nfunc init() {  govalidator.SetFieldsRequiredByDefault(true) } Sau đó trường nào không cần require thì thêm tag valid:\u0026quot;-\u0026quot;.\nĐể thay đổi message báo lỗi mặc định ta dùng ký tự ~ vào sau kiểu validate (chú ý không có khoảng trắng):\nEmail string `valid:\u0026#34;email~Email không hợp lệ\u0026#34; Nếu một field validate nhiều kiểu dữ liệu thì ngăn cách bằng dấu phẩy, và nếu có custom message thì cần thiết lập riêng message cho từng kiểu dữ liệu:\nName string `valid:\u0026#34;required~Tên không được để trống,runelength(1|50)~Tên không hợp lệ (từ 1 - 50 ký tự)\u0026#34; ","permalink":"https://huydq.dev/blog/validate-du-lieu-trong-go-su-dung-govalidator/","summary":"Trong các ứng dụng cho phép người dùng nhập dữ liệu thì đều cần phải có validate để bảo mật và đảm bảo ứng dụng chạy đúng.\nGolang có một số thư viện open source hỗ trợ chúng ta làm việc này một cách nhanh chóng, ví dụ như govalidator.\nCài đặt Cài govalidator qua package manager hoặc đơn giản là dùng go get:\ngo get github.com/asaskevich/govalidator Import vào trong project:","title":"Validate dữ liệu trong Go sử dụng Govalidator"},{"content":"Go không phải một ngôn ngữ hướng đối tượng (OOP). Tuy nhiên chúng ta có thể áp dụng một số ưu điểm của hướng đối tượng vào trong Go.\nChúng ta có Struct (tương tự Class), Interface và Method. Để sử dụng thuộc tính \u0026ldquo;kế thừa\u0026rdquo; trong Go ta sẽ dùng embedded type.\nEmbedded Type là khai báo một type nằm trong một type khác nhưng không khai báo tên, trường mà không khai báo tên còn được gọi là embedded field. Ví dụ như sau type Author struct {  AuthorName string  AuthorAge int }  type Post struct {  Title string  Content string  Author // Embedded field } Trong ví dụ trên nếu chúng ta đặt tên cho trường Author như bình thường thì chúng ta sẽ có Struct lồng nhau, còn nếu dùng Embedded field thì chúng ta có thể coi như Struct Post có đầy đủ các trường của cả 2 Struct (tên trường không được phép trùng nhau)\n// Tương tự ví dụ trên type Post struct {  Title string  Content string  AuthorName string  AuthorAge int } Bằng cách này chúng ta sẽ có thể sử dụng cả 2 Struct Post và Author mà không cần khai báo lại các trường trùng lặp.\nKhi lấy dữ liệu cũng có thể lấy trực tiếp mà không cần qua Struct trung gian, ví dụ lấy tên tác giả thay vì post.Author.AuthorName thì ta chỉ cần post.AuthorName. Xem ví dụ đầy đủ tại đây.\nVí dụ khác Với một project có sử dụng database.\n  Khi tương tác với database ta sẽ dùng Struct User:\ntype User struct {  Id int  Role int  Name string  Email string  Password string }   Dữ liệu gửi lên có thể là một Struct khác ít thông tin hơn, ví dụ như chức năng Login chỉ cần Emailvà Password. Lúc này ta có thêm Struct Login chẳng hạn:\ntype Login struct {  Email string  Password string }   Như vậy 2 trường Email và Password bị trùng lặp và khi cần lấy dữ liệu ta có 2 Struct khác nhau, cần phải gán dữ liệu từng trường. Trong trường hợp này ta có thể dùng embedded type để giảm bớt thao tác khai báo và gán dữ liệu.\n","permalink":"https://huydq.dev/blog/golang-embedded-type-ke-thua-trong-go/","summary":"Go không phải một ngôn ngữ hướng đối tượng (OOP). Tuy nhiên chúng ta có thể áp dụng một số ưu điểm của hướng đối tượng vào trong Go.\nChúng ta có Struct (tương tự Class), Interface và Method. Để sử dụng thuộc tính \u0026ldquo;kế thừa\u0026rdquo; trong Go ta sẽ dùng embedded type.\nEmbedded Type là khai báo một type nằm trong một type khác nhưng không khai báo tên, trường mà không khai báo tên còn được gọi là embedded field.","title":"Golang embedded type - Kế thừa trong Go"},{"content":"Để sử dụng 1 package trong Go ta dùng lệnh import:\n  Với local package (các package nằm trong project) thì ta có thể sử dụng đường dẫn tương đối.\n  Với external package (các package bên ngoài project) thì ta sẽ phải cài đặt vào trong $GOPATH (đây là một biến môi trường để thiết lập nơi cài package).\n  Để cài đặt package thì chúng ta có thể dùng các cách sau:\nGo Get Đây là package manager mặc định của Go, nó giúp chúng ta cài external package vào $GOPATH, ví dụ cài package go-pg(PostgreSQL ORM cho Go):\ngo get github.com/go-pg/pg Lệnh trên sẽ tải thư viện github.com/go-pg/pg và lưu vào trong đường dẫn $GOPATH/src. Ví dụ $GOPATH=\u0026quot;/home/robin\u0026quot; thì package sẽ được tải về và lưu vào trong đường dẫn /home/robin/src với cấu trúc thư mục là [domain]/[organization]/[repository](để tránh trùng lặp vì các package có thể trùng tên)\nƯu điểm khi sử dụng go get:\n Quản lý package theo kiểu phân tán (decentralized), các package không lưu tập trung trong project mà lưu trong $GOPATH. Package chỉ cần cài một lần, sử dụng được cho nhiều project (chỉ cần import không cần cài lại). Các package có thể gọi lẫn nhau mà không bị chồng chéo (package lồng vào nhau nhiều cấp). Một số package cung cấp file binary đặt trong $GOPATH/bin, cho phép chúng ta sử dụng ở mọi chỗ (ví dụ protoc-gen-go cho phép tạo ra code Go từ file Proto).  Nhược điểm:\n Khi cài package phải cài từng gói và trong một project lớn sẽ không rõ có những package nào đang được sử dụng. Không quản lý được version của package. Go get luôn lấy package từ HEAD của default branch (code mới nhất), do đó package trong Go phải luôn đảm bảo stable. Thực ra đây cũng không hẳn là nhược điểm bởi các package của Go sẽ luôn publish theo cách ổn định nhất, nếu package có version mới không tương thích ngược toàn bộ với version cũ thì sẽ đặt ở một repository khác.  Dep Dep cũng là một package manager cho Go. Nó cung cấp một số chức năng mà go get không có:\n Quản lý được các package sử dụng trong project. Cài nhiều package một lúc dựa vào phân tích code và thiết lập được version của các package.  Dep cũng có nhược điểm như: Khó sử dụng hơn go get, khó import local package, \u0026hellip; do đó cần cân nhắc trước khi sử dụng.\nChúng ta có thể cài Dep qua go get, trên MacOS thì có thể dùng Homebrew, còn với các hệ điều hành khác ta chạy lệnh sau:\ncurl https://raw.githubusercontent.com/golang/dep/master/install.sh | sh Sau khi cài xong, chúng ta có thể dùng lệnh dep trên terminal để cài các package.\ndep init dep ensure Lệnh dep init dùng để khởi tạo ra môi trường làm việc với Dep, nó sẽ sinh ra thư mục vendor ngay trong project để chứa các package đã cài thay cho $GOPATH và 2 files:\n Gopkg.toml: Định nghĩa một số quy định quản lý của Dep như phiên bản nào của package được sử dụng, source của package, \u0026hellip; (tương tự package.json của npm hay gemfile của Ruby, \u0026hellip;). Gopkg.lock: Được tự động sinh ra mỗi khi thực hiện lệnh dep init hoặc dep ensure, nó như một bản snapshot, ghi lại các trạng thái và thao tác khi update hay cài đặt package.  Lệnh dep ensure dùng để cài đặt các package dựa vào file Gopkg.toml và các file .go trong project (Dep sẽ đọc các lệnh import trong các file .go để tìm ra các package đang sử dụng). Các package được cài vào trong thư mục vendor của project với cấu trúc giống như trong $GOPATH.\nMột số chú ý khi sử dụng Dep:\n Project phải được đặt trong $GOPATH như các package khác. Khi lần đầu chạy dep init nếu là một project có sẵn chưa sử dụng Dep thì thời gian chạy lệnh có thể lâu do Dep phải đọc toàn bộ source có sẵn để tìm ra các package đang sử dụng. Nếu import local package thì không sử dụng đường dẫn tương đối như go get mà sử dụng đường dẫn như với các external package.  Tham khảo thêm về Dep: https://golang.github.io/dep/docs/introduction.html\nGlide Tương tự như Deb, tuy nhiên theo quan điểm cá nhân thì Glide dễ dùng hơn Deb.\nCài đặt: xem hướng dẫn tại đây: https://github.com/Masterminds/glide#install\nCách dùng cũng tương tự Deb, có 2 file là:\n glide.lock: lưu thông tin version của các package đã cài đặt glide.yaml: dùng để cấu hình các package dùng cho dự án.  Một số lệnh dùng trong Glide:\n$ glide create # Khởi tạo project $ glide get github.com/Masterminds/cookoo # Lấy package và thêm vào glide.yaml $ glide install # Cài đặt package $ glide up # Update version mới của package (theo glide.yaml) ","permalink":"https://huydq.dev/blog/quan-ly-package-trong-go/","summary":"Để sử dụng 1 package trong Go ta dùng lệnh import:\n  Với local package (các package nằm trong project) thì ta có thể sử dụng đường dẫn tương đối.\n  Với external package (các package bên ngoài project) thì ta sẽ phải cài đặt vào trong $GOPATH (đây là một biến môi trường để thiết lập nơi cài package).\n  Để cài đặt package thì chúng ta có thể dùng các cách sau:","title":"Quản lý package trong Go"},{"content":"Các phần trước:\nPhần 1: Packages, variables và functions.\nPhần 2: Điều khiển luồng với if, else, switch và defer.\nPhần 3: Arrays và Slices.\nPhần 4: Structs và Maps.\nMethods Trong Go không có class, chúng ta có thể dùng struct thay cho class như ở phần trước. Tuy nhiên trong struct mới chỉ có thuộc tính chứ chưa có phương thức. Để ứng dụng được phương thức (method) như các ngôn ngữ hướng đối tượng khác ta sẽ cần khai báo function kèm theo một tham số đặc biệt gọi là receiver argument. Receiver argument nằm ở giữa từ khóa func và tên của function, nó sẽ chỉ ra một type(thường là một struct) để áp dụng hàm này làm phương thức. Ví dụ:\npackage main  import (  \u0026#34;fmt\u0026#34;  \u0026#34;math\u0026#34; )  // Định nghĩa struct Vertex với 2 thuộc tính X và Y type Vertex struct {  X, Y float64 }  // Tạo phương thức Abs() cho struct Vertex (receiver argument) func (v Vertex) Abs() float64 {  return math.Sqrt(v.X*v.X + v.Y*v.Y) }  func main() {  // Khởi tạo struct  v := Vertex{3, 4}   // Gọi phương thức Abs() của struct  fmt.Println(v.Abs()) } Interfaces Interface là một định nghĩa các tập hợp phương thức mà một đối tượng cần tuân thủ (tương tự như ở trong các ngôn ngữ hướng đối tượng khác). Khi một type có chứa các phương thức như đã khai báo trong interface thì nó đang triển khai (implement) interface đó. Ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  // Định nghĩa interface I với 1 method là M() type I interface {  M() }  // Định nghĩa struct T với 1 field là S kiểu string type T struct {  S string }  // Định nghĩa phương thức M() cho struct T // Struct T sẽ tự động implement interface I func (t T) M() {  fmt.Println(t.S) }  func main() {  // Khởi tạo biến i có kiểu là interface I  var i I = T{\u0026#34;hello\u0026#34;}   // Gọi phương thức M()  i.M() } Type đã triển khai interface buộc phải có đầy đủ các method được định nghĩa trong interface. Ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  // Định nghĩa interface I với 1 method là M() và N() type I interface {  M(),  N() }  // Định nghĩa struct T type T struct {  S string }  // Định nghĩa phương thức M() cho struct T // Struct T sẽ tự động implement interface I func (t T) M() {  fmt.Println(t.S) }  func main() {  // Khởi tạo biến i có kiểu là interface I  var i I = T{\u0026#34;hello\u0026#34;}   // Gọi phương thức M()  i.M()   // Kết quả sẽ báo lỗi vì struct T implement interface I,  // nhưng không có đủ các method đã khai báo (thiếu method N()) } Một interface mà không có chứa method nào thì gọi là interface rỗng ( Emtpy Interface). Interface rỗng có thể lưu mọi loại dữ liệu nên thường được dùng trong trường hợp các hàm xử lý mà cần tham số động (không biết trước kiểu dữ liệu). Ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar i interface{} // i là một empty interface   // Họi hàm describe với tham số truyền vào là một số \ti = 42 \tdescribe(i)   // Họi hàm describe với tham số truyền vào là một chuỗi \ti = \u0026#34;hello\u0026#34; \tdescribe(i) }  // Hàm describe có tham số truyền vào là một empty interface // do đó khi thực thi ta có thể truyền vào kiểu dữ liệu nào cũng được func describe(i interface{}) { \tfmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, i, i) } Series Học Go cấp tốc sẽ tạm dừng ở đây. Mục đích là để các bạn làm quen và nắm được tổng quan của ngôn ngữ Go. Sẽ có một Series khác hướng dẫn chi tiết hơn về lập trình Golang dành cho những ai muốn tìm hiểu sâu hơn để áp dụng vào công việc thực tế.\nHappy coding 😎\n","permalink":"https://huydq.dev/blog/hoc-go-cap-toc-phan-5-methods-va-interfaces/","summary":"Các phần trước:\nPhần 1: Packages, variables và functions.\nPhần 2: Điều khiển luồng với if, else, switch và defer.\nPhần 3: Arrays và Slices.\nPhần 4: Structs và Maps.\nMethods Trong Go không có class, chúng ta có thể dùng struct thay cho class như ở phần trước. Tuy nhiên trong struct mới chỉ có thuộc tính chứ chưa có phương thức. Để ứng dụng được phương thức (method) như các ngôn ngữ hướng đối tượng khác ta sẽ cần khai báo function kèm theo một tham số đặc biệt gọi là receiver argument.","title":"Học Go cấp tốc Phần 5:  Methods và Interfaces"},{"content":"Các phần trước:\nPhần 1: Packages, variables và functions.\nPhần 2: Điều khiển luồng với if, else, switch và defer.\nPhần 3: Arrays và Slices.\nStructs Tương tự C, một struct trong Go là tập hợp các trường (field) do người dùng tự định nghĩa. Mỗi trường có thể có kiểu dữ liệu khác nhau, thậm chí có thể là một struct. Trong Go không có class như các ngôn ngữ hướng đối tượng, do đó chúng ta có thể dùng struct thay cho class. Ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  // Định nghĩa một struct với từ khóa type type Student struct { \tname string \tage int }  func main() {  // Khởi tạo biến s1 có giá trị là struct Student  s1 := Student{\u0026#34;Robin\u0026#34;, 30} // {\u0026#34;Robin\u0026#34;, 30}   // Khởi tạo biến s2 có giá trị là struct Student với 1 field là name  // Field còn lại sẽ có giá trị mặc định (zero value)  s2 := Student{name: \u0026#34;Robin\u0026#34;} // {\u0026#34;Robin\u0026#34;, 0}   // Khởi tạo biến s3 có giá trị là struct Student và không khai báo giá trị cho trường nào  s3 := Student{} // {\u0026#34;\u0026#34;, 0}   // Thay đổi giá trị field trong struct  s3.name = \u0026#34;Robert\u0026#34;  s3.age = 25   fmt.Println(s3) // s3 = {\u0026#34;Robert\u0026#34;, 25} } Struct có thể so sánh được nếu các field của nó có thể so sánh được, và 2 biến kiểu struct có giá trị giống nhau nếu toàn bộ các field có giá trị giống nhau:\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  type Student struct { \tname string \tage int }  func main() { \ts1 := Student{\u0026#34;Steve\u0026#34;, 30} \ts2 := Student{\u0026#34;Steve\u0026#34;, 30}  s3 := Student{\u0026#34;Job\u0026#34;, 30}  \tif s1 == s2 { \tfmt.Println(\u0026#34;s1 = s2\u0026#34;) // s1 bằng s2 \t} else { \tfmt.Println(\u0026#34;s1 != s2\u0026#34;) \t}  \tif s2 == s3 { \tfmt.Println(\u0026#34;s2 = s3\u0026#34;) \t} else { \tfmt.Println(\u0026#34;s2 != s3\u0026#34;) // s2 khác s3 \t} } Maps Map là một tập hợp các phần tử được lưu trữ dưới dạng key - value. Key trong map có kiểu dữ liệu so sánh được và không bị trùng lặp . Để tạo map ta dùng hàm make() với công thức như sau:\nmake(map[type of key]type of value // Định nghĩa biến demoMap có kiểu dữ liệu map với key kiểu string và value kiểu int var demoMap map[string]int  // Map không so sánh được như struct, nhưng có thể dùng toán tử == để kiểm tra nil if demoMap == nil {  fmt.Println(\u0026#34;Map có giá trị nil.\u0026#34;)   // Tạo Map bằng hàm make  demoMap = make(map[string]int) } Thêm phần tử hoặc thay đổi giá trị của một phần tử trong map m ta dùng công thức:\nm[key] = value // Khởi tạo map languages := make(map[string]float32)  // Thêm phần tử vào map languages[\u0026#34;go\u0026#34;] = 0.63 languages[\u0026#34;java\u0026#34;] = 1.03  // Cập nhật lại giá trị của phần tử \u0026#34;go\u0026#34; languages[\u0026#34;go\u0026#34;] = 0.73  fmt.Println(languages) // map[go:0.73 java:1.03] Để xóa phần tử trong map thì ta dùng hàm delete() và cung cấp key của phần tử cần xóa. Ví dụ xóa phần tử có key = \u0026ldquo;go\u0026rdquo; trong map languages:\ndelete(languages, \u0026#34;go\u0026#34;) Để truy xuất đến phần tử trong map, ta gọi map kèm theo key của phần tử. Nếu key đó không tồn tại thì ta sẽ thu được giá trị là zero value (tùy theo kiểu dữ liệu). Ví dụ:\nm := make(map[string]int)  m[\u0026#34;Answer\u0026#34;] = 42 fmt.Println(m[\u0026#34;Answer\u0026#34;]) // Lấy giá trị của phần tử có key = \u0026#34;Answer\u0026#34;, kết quả là 42  delete(m, \u0026#34;Answer\u0026#34;) fmt.Println(m[\u0026#34;Answer\u0026#34;]) // Phần tử có key = \u0026#34;Answer\u0026#34; đã bị xóa, kết quả là 0 (zero value của int) Để kiểm tra xem một phần tử có tồn tại trong map hay không, ta sẽ lấy cùng lúc 2 kết quả khi truy xuất đến phần tử trong map. Giá trị đầu tiên giống ví dụ trên, giá trị thứ 2 sẽ là true nếu phần tử có trong map và false nếu phần tử không tồn tại (gần giống callback error trong javascript).\n// Tiếp theo ví dụ trên v, ok := m[\u0026#34;Answer\u0026#34;] fmt.Println(\u0026#34;Giá trị của phần tử là: \u0026#34;, v) // v = 0 fmt.Println(\u0026#34;Kiểm tra phần tử có tồn tại hay không: \u0026#34;, ok) // ok = false Tiếp theo: Phần 5: Methods và Interfaces.\n","permalink":"https://huydq.dev/blog/hoc-go-cap-toc-phan-4-structs-va-maps/","summary":"Các phần trước:\nPhần 1: Packages, variables và functions.\nPhần 2: Điều khiển luồng với if, else, switch và defer.\nPhần 3: Arrays và Slices.\nStructs Tương tự C, một struct trong Go là tập hợp các trường (field) do người dùng tự định nghĩa. Mỗi trường có thể có kiểu dữ liệu khác nhau, thậm chí có thể là một struct. Trong Go không có class như các ngôn ngữ hướng đối tượng, do đó chúng ta có thể dùng struct thay cho class.","title":"Học Go cấp tốc Phần 4:  Structs và Maps"},{"content":"Các phần trước:\nPhần 1: Packages, variables và functions.\nPhần 2: Điều khiển luồng với if, else, switch và defer.\nArrays Array (mảng) trong Go tương tự các ngôn ngữ khác, tuy nhiên nó có kích thước cố định (fixed size) và các phần tử bên trong phải cùng loại dữ liệu. Ví dụ:\n// Khởi tạo một mảng gồm 2 string var a [2]string  // Gán giá trị cho các phần tử trong mảng a[0] = \u0026#34;Hello\u0026#34; a[1] = \u0026#34;World\u0026#34;  // In kết quả ra console fmt.Println(a[0], a[1]) fmt.Println(a)  // Khởi tạo một mảng gồm 6 số int và gán luôn giá trị cho nó primes := [6]int{2, 3, 5, 7, 11, 13} fmt.Println(primes)  // Khởi tạo mảng nhưng không ghi rõ kích thước (thay bằng dấu ba chấm), // trình biên dịch sẽ tự hiểu dựa vào số phần tử đã khai báo numbers := [...]int{12, 78, 50} fmt.Println(numbers) Không giống đa số các ngôn ngữ khác, Array trong Go không phải là dạng tham chiếu (reference types) mà là dạng tham trị (value types). Khi gán giá trị nó cho một biến mới thì nó sẽ tạo ra một bản copy của Array cũ, và mọi thay đổi ở Array mới không ảnh hưởng gì đến Array cũ:\na := [...]int{1, 2, 3, 4, 5} b := a // b là một array mới có giá trị giống a b[0] = 9 // Thay đổi giá trị một phần tử của b  fmt.Println(\u0026#34;a is \u0026#34;, a) // In ra 1 2 3 4 5 fmt.Println(\u0026#34;b is \u0026#34;, b) // In ra 9 2 3 4 5 Slices Slice là một tham chiếu đến Array, nó mô tả một phần (hoặc toàn bộ) Array. Nó có kích thước động nên thường được sử dụng nhiều hơn Array.\nSlice có thể tạo ra từ một Array bằng cách cung cấp 2 chỉ số (low và high) xác định vị trí phần tử trong Array. Ví dụ:\n// Khởi tạo Array primes primes := [6]int{2, 3, 5, 7, 11, 13}  // Khởi tạo Slice s bằng cách cắt từ phần tử ở vị trí 1 (low) đến phần tử ở vị trí 3 (high - 1) của Array primes var s []int = primes[1:4]  // In ra giá trị của Slice s fmt.Println(s) // Giá trị của s là [3, 5, 7] Một Slice sẽ có 2 thuộc tính là length(len)và capacity(cap). Length là số phần tử chứa trong Slice, còn capacity là số phần tử chứa trong Array mà Slice tham chiếu đến (bắt đầu tính từ phần tử đầu tiên của Slice). Để lấy ra length của Slice ta dùng hàm len(), còn để lấy ra capacity thì ta dùng hàm cap(). Ví dụ:\ns := []int{2, 3, 5, 7, 11, 13}  s = s[0:0] // s = [], len(s) = 0, cap(s) = 6 s = s[0:4] // s = [2, 3, 5, 7], len(s) = 4, cap(s) = 6 s = s[2:4] // s = [5, 7], len(s) = 2, cap(s) = 4, cap được tính từ vị trí số 2 trở đi s = s[0:4] // s = [5, 7, 11, 13], len(s) = 4, cap(s) = 4 Khi tạo Slice ta có thể bỏ qua các chỉ số low và high, khi đó Go sẽ tự sử dụng giá trị mặc định: 0 cho low và length của Slice cho high. Ví dụ:\ns := []int{2, 3, 5, 7, 11, 13}  s = s[:0] // s = [0:0] s = s[:4] // s = [0:4] s = s[2:] // s = [2:len(s)] =\u0026gt; s = [2:4] s = s[:4] // s = [0:4] Ngoài việc tạo Slice như trên, chúng ta có thể tạo theo các cách sau:\n  Khai báo như một mảng nhưng không chỉ ra kích thước mảng:\nq := []int{2, 3, 5, 7, 11, 13}   Sử dụng hàm make() với công thức sau:\nfunc make([]T, len, cap) []T a := make([]int, 5) // len(a)=5 b := make([]int, 0, 5) // len(b)=0, cap(b)=5   Slice có zero value là nil (length = 0 và capacity = 0), nil tương đương với giá trị null trong các ngôn ngữ lập trình khác.\nDo Slice chỉ là tham chiếu đến Array, do đó thay đổi giá trị của Slice sẽ làm thay đổi giá trị của Array mà nó tham chiếu đến. Nếu có nhiều Slice cùng tham chiếu đến một Array thì khi thay đổi giá trị một Slice có thể làm thay đổi giá trị các Slice khác. Ví dụ:\nnumbers := [4]int{1, 2, 3, 4}  a := numbers[0:2] // a = [1, 2] b := numbers[1:3] // b = [2, 3]  b[0] = 5 // Thay đổi giá trị phần tử đầu tiên của Slice b  fmt.Println(a, b) // a = [1, 5], b = [5, 3] fmt.Println(numbers) // numbers = [1, 5, 3, 4] Append Để bổ sung thêm phần tử cho slice, ta dùng hàm append() với công thức sau:\nfunc append(s []T, vs ...T) []T Hàm này sẽ trả về một slice có chứa toàn bộ các phần tử của slice ban đầu và các phần tử mới thêm vào. Trong trường hợp slice ban đầu có sức chứa nhỏ (Array mà nó tham chiếu đến có size nhỏ), một Array mới có kích thước lớn hơn sẽ được tạo ra và slice mới sẽ tham chiếu đến Array đó.\nvar s []int  // Append có thể hoạt động với nil slice. s = append(s, 0) // s = [0]  // Append thêm một phần tử vào slice. s = append(s, 1) // s = [0, 1]  // Append thêm nhiều phần tử vào slice. s = append(s, 2, 3, 4) // s = [0, 1, 2, 3, 4] Range Range là một hình thức của vòng lặp for dùng để duyệt qua một slice hoặc map(sẽ nhắc đến ở phần sau). Mỗi một vòng lặp sẽ trả về 2 giá trị: Giá trị đầu tiên là chỉ số (vị trí) của phần tử, và giá trị thứ hai là bản sao của phần tử đó (cùng giá trị). Ví dụ:\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128} for i, v := range pow {  fmt.Printf(\u0026#34;i = %d, v = %d \\n\u0026#34;, i, v) } Trong trường hợp khi lặp chỉ sử dụng 1 trong 2 giá trị trả về thì ta sẽ bỏ qua giá trị còn lại bằng cách thay tên biến bằng ký tự gạch dưới (vì nếu không thì khi biên dịch sẽ báo lỗi biến được định nghĩa mà không sử dụng). Ví dụ:\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128} for _, v := range pow {  fmt.Printf(\u0026#34;v = %d \\n\u0026#34;, v) } Tiếp theo: Phần 4: Structs và Maps.\n","permalink":"https://huydq.dev/blog/hoc-go-cap-toc-phan-3-arrays-va-slices/","summary":"Các phần trước:\nPhần 1: Packages, variables và functions.\nPhần 2: Điều khiển luồng với if, else, switch và defer.\nArrays Array (mảng) trong Go tương tự các ngôn ngữ khác, tuy nhiên nó có kích thước cố định (fixed size) và các phần tử bên trong phải cùng loại dữ liệu. Ví dụ:\n// Khởi tạo một mảng gồm 2 string var a [2]string  // Gán giá trị cho các phần tử trong mảng a[0] = \u0026#34;Hello\u0026#34; a[1] = \u0026#34;World\u0026#34;  // In kết quả ra console fmt.","title":"Học Go cấp tốc Phần 3:  Arrays và Slices"},{"content":"Phần trước: Học Go cấp tốc Phần 1: Packages, variables và functions.\nPhần tiếp theo chúng ta sẽ cùng tìm hiểu cách điều khiển luồng (flow control) trong Go.\nVòng lặp Trong Go chỉ có 1 kiểu vòng lặp là sử dụng for. Cách dùng tương tự các ngôn ngữ khác nhưng phần khai báo biến, điều kiện lặp, \u0026hellip; không cần đặt trong cặp ngoặc tròn:\n// Tính tổng các số từ 0 - 9 sum := 0 for i := 0; i \u0026lt; 10; i++ {  sum += i } fmt.Println(sum) Vòng lặp for khi chỉ có điều kiện lặp thì hoạt động giống while trong các ngôn ngữ khác:\nsum := 0 for sum \u0026lt; 10 {  sum += 1 } fmt.Println(sum) Điều kiện Lệnh điều kiện trong Go sử dụng if, else, switch, và cũng như vòng lặp for chúng ta không cần cặp ngoặc tròn.\nVới câu lệnh if chúng ta có thể khai báo biến ngay trong câu lệnh điều kiện, và biến này sẽ chỉ hoạt động ở trong block của lệnh if hoặc else:\nimport (  \u0026#34;fmt\u0026#34;  \u0026#34;math\u0026#34; )  func pow(x, n, limit float64) float64 {  // Khai báo biến v trong lệnh điều kiện của if sẽ chỉ sử dụng được trong block if hoặc else  if v := math.Pow(x, n); v \u0026lt; limit {  return v  } else {  fmt.Printf(\u0026#34;%g \u0026gt;= %g\\n\u0026#34;, v, limit) \t}  \t// Không sử dụng được biến v ở bên ngoài, ví dụ return v sẽ báo lỗi \treturn lim } Lệnh switch tương tự các ngôn ngữ khác, tuy nhiên có một số điểm khác biệt:\n  Biểu thức trong switch không được sử dụng hằng số (constant). Không cần lệnh break trong mỗi case(mặc định các case tự break). Do đó chỉ có trường hợp thỏa mãn đầu tiên được chạy (tính từ trên xuống dưới). Ví dụ:\nswitch num := 10; {  case num \u0026lt; 50:  fmt.Printf(\u0026#34;%d \u0026lt; 50\\n\u0026#34;, num) // In ra 10 \u0026lt; 50  case num \u0026lt; 100:  fmt.Printf(\u0026#34;%d \u0026lt; 100\\n\u0026#34;, num) // Lệnh này không chạy mặc dù cũng thỏa mãn điều kiện  default:  fmt.Printf(\u0026#34;I don\u0026#39;t know\u0026#34;, num) }   Có thể sử dụng nhiều điều kiện trong một case,hoặc sử dụng từ khóa fallthrough để cho phép chạy tiếp xuống câu lệnh tiếp theo:\nnum := 10;  switch { // Tương đương với switch true  case num \u0026gt;= 0 \u0026amp;\u0026amp; num \u0026lt;= 50:  fmt.Printf(\u0026#34;%d \u0026lt; 50 \\n\u0026#34;, num) // In ra 10 \u0026lt; 50  fallthrough  case num \u0026lt; 100:  fmt.Printf(\u0026#34;%d \u0026lt; 100 \\n\u0026#34;, num) // In ra 10 \u0026lt; 100  default:  fmt.Printf(\u0026#34;I don\u0026#39;t know\u0026#34;, num) }   Trì hoãn Trì hoãn (defer) là một khái niệm khá mới trong điều khiển luồng. Nó cho phép một câu lệnh được gọi ra nhưng không thực thi ngay mà hoãn lại đến khi các lệnh xung quanh trả về kết quả. Ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  func main() {  defer fmt.Println(\u0026#34;World\u0026#34;) // Hoãn lệnh in ra chữ \u0026#34;World\u0026#34;  fmt.Println(\u0026#34;Hello\u0026#34;) // In ra chữ \u0026#34;Hello\u0026#34;  // Kết quả cuối cùng là \u0026#34;Hello World\u0026#34; } Các lệnh được gọi qua từ khóa defer sẽ được đưa vào một stack, tức là hoạt động theo cơ chế vào sau ra trước (last-in-first-out). Lệnh nào defer sau sẽ được thực thi trước, giống như xếp 1 chồng đĩa thì chiếc đĩa sau cùng (ở trên cùng) sẽ được lấy ra trước. Ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  func main() {  for i := 0; i \u0026lt; 10; i++ {  defer fmt.Println(i) // In ra giá trị của biến i  }   // Kết quả trả về ngược so với vòng lặp:  // 9 8 7 6 5 4 3 2 1 0 } Chú ý là khi gọi lệnh defer thì giá trị của biến trong câu lệnh sẽ là giá trị tại thời điểm gọi chứ không phải giá trị tại thời điểm thực thi.\nTiếp theo: Phần 3: Arrays và Slices.\n","permalink":"https://huydq.dev/blog/hoc-go-cap-toc-phan-2-dieu-khien-luong-voi-if-else-switch-va-defer/","summary":"Phần trước: Học Go cấp tốc Phần 1: Packages, variables và functions.\nPhần tiếp theo chúng ta sẽ cùng tìm hiểu cách điều khiển luồng (flow control) trong Go.\nVòng lặp Trong Go chỉ có 1 kiểu vòng lặp là sử dụng for. Cách dùng tương tự các ngôn ngữ khác nhưng phần khai báo biến, điều kiện lặp, \u0026hellip; không cần đặt trong cặp ngoặc tròn:\n// Tính tổng các số từ 0 - 9 sum := 0 for i := 0; i \u0026lt; 10; i++ {  sum += i } fmt.","title":"Học Go cấp tốc Phần 2:  Điều khiển luồng với if, else, switch và defer"},{"content":" Go(hay thường được gọi là Golang) là một ngôn ngữ lập trình mã nguồn mở được tạo ở Google vào năm 2009 bởi Robert Griesemer, Rob Pike, và Ken Thompson. Nó được ra đời nhằm mục đích phát triển các trang web nhanh hơn, dễ dàng hơn và đáp ứng được yêu cầu truy cập lớn. Về lịch sử ra đời cũng như giới thiệu chi tiết hơn các bạn có thể xem ở wikipedia 😅\n Để học Go thì chúng ta có nhiều nguồn và tài liệu khác nhau. Với những người đã biết ít nhất một ngôn ngữ lập trình thì có thể thực hành luôn theo theo Tour Golang, nó sẽ gồm các ví dụ và bài tập mẫu mô tả các chức năng cơ bản trong Go và đi kèm 1 editor online để chúng ta có thể thực hành luôn mà không cần cài đặt.\nTrong quá trình học theo Tour Golang, mình sẽ viết bài tổng kết lại một số kiến thức cơ bản, điểm khác biệt của Go so với các ngôn ngữ khác (có thể sẽ sử dụng ví dụ khác với nguyên mẫu). Nếu bạn muốn học Go và thực hành luôn trên Tour Golang thì có thể tham khảo series này (hoặc có thể đọc lướt qua để có một cái nhìn tổng quát về Go).\nPackages Mọi chương trình viết từ Go đều được tạo bởi các package và package chính dùng để chạy là main.\nĐể sử dụng các package khác thì chúng ta phải import, ví dụ muốn in 1 đoạn text ra console thì ta phải dùng package fmt:\npackage main  import \u0026#34;fmt\u0026#34;  func main() {  fmt.Println(\u0026#34;Lại là Hello World\u0026#34;) } Variables Cú pháp của Go tương tự C nhưng cũng có nhiều điểm khác, ví dụ không có dấu chấm phẩy ở cuối các câu lệnh hay kiểu dữ liệu được khai báo ở sau tên biến. Về việc tại sao Go lại khai báo kiểu dữ liệu ngược so với hầu hết các ngôn ngữ khác các bạn tự tìm hiểu tại đây Go\u0026rsquo;s Declaration Syntax.\nKhai báo biến trong Go ngoài việc cú pháp hơi dị một chút, còn đâu thì vẫn tương tự như các ngôn ngữ khác:\n// Khai báo biến message có kiểu dữ liệu string var message string  // Khai báo 3 biến c, python, java đều có kiểu dữ liệu là bool var c, python, java bool  // Khai báo 2 biến i, j có kiểu dữ liệu là int và khởi tạo luôn giá trị cho chúng var i, j int = 1, 2  // Khai báo ngắn gọn biến k và khởi tạo giá trị luôn cho nó. // Không dùng từ khóa var mà dùng dấu hai chấm, lúc này kiểu dữ liệu sẽ được ngầm định tùy theo giá trị của biến. k := 3 Các kiểu dữ liệu trong Go, ở phần mô tả của Tour of Go có liệt kê đầy đủ: Go basic types\nKhi khai báo biến mà không khởi tạo giá trị ban đầu cho nó thì biến đó sẽ có giá trị zero tùy thuộc vào kiểu dữ liệu:\n 0 cho kiểu số. false cho kiểu boolean. \u0026quot;\u0026quot; cho kiểu chuỗi.  Khi thực hiện tính toán giữa các biến với kiểu dữ liệu khác nhau sẽ cần ép kiểu (type conversions) theo công thức T(v) với T là kiểu dữ liệu (type) còn v là giá trị (value):\ni := 55 // kiểu int j := 67.8 // kiểu float64 sum := i + int(j) // Để tính tổng cần phải ép kiểu j về int (sum = 55 + 67) fmt.Println(sum) // Kết quả trả về là 122 Khai báo hằng số thì tương tự khai báo biến nhưng dùng từ khóa const và không dùng được cú pháp viết tắt :=\nconst Pi = 3.14 Functions Khai báo hàm sử dụng từ khóa func, và chú ý tham số truyền vào cũng khai báo kiểu dữ liệu sau tên tham số:\n// Hàm tính tổng, có 2 tham số truyền vào với kiểu dữ liệu int và kết quả trả về cũng là int func add(x int, y int) int {  return x + y } Khi các tham số truyền vào cùng kiểu dữ liệu thì có thể viết tắt như sau:\n// Hàm tính tổng, có 2 tham số truyền vào với kiểu dữ liệu int và kết quả trả về cũng là int func add(x, y int) int {  return x + y } Điểm đặc biệt trong Go đó là function có thể trả về nhiều kết quả, ví dụ:\npackage main  import \u0026#34;fmt\u0026#34;  // Hàm swap trả về kết quả là 2 chuỗi func swap(x, y string) (string, string) { \treturn y, x }  func main() {  // Gán kết quả của hàm swap vào 2 biến a và b  a, b := swap(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;)   // In ra giá trị của a và b  fmt.Println(a, b) } Kết quả trả về có thể đặt tên để sử dụng luôn trong hàm, ví dụ:\n// Hàm split khai báo 2 kết quả trả về là x và y có kiểu dữ liệu là int func split(sum int) (x, y int) {  x = sum * 4 / 9  y = sum - x   // return có thể để trống, function sẽ tự động trả về x và y (không khuyến khích)  return } Tiếp theo: Phần 2: Điều khiển luồng với if, else, switch và defer.\n","permalink":"https://huydq.dev/blog/hoc-go-cap-toc-phan-1-packages-variables-va-functions/","summary":"Go(hay thường được gọi là Golang) là một ngôn ngữ lập trình mã nguồn mở được tạo ở Google vào năm 2009 bởi Robert Griesemer, Rob Pike, và Ken Thompson. Nó được ra đời nhằm mục đích phát triển các trang web nhanh hơn, dễ dàng hơn và đáp ứng được yêu cầu truy cập lớn. Về lịch sử ra đời cũng như giới thiệu chi tiết hơn các bạn có thể xem ở wikipedia 😅","title":"Học Go cấp tốc Phần 1: Packages, variables và functions"},{"content":"Kong cung cấp một RESTful Admin API cho phép chúng ta thực hiện việc cấu hình và quản lý các API. Mặc định Admin API sẽ lắng nghe ở cổng 8001 và cổng 8444 cho giao thức https. Chú ý API này chỉ dùng trong nội bộ, không public ra ngoài, vì nó cho phép quản lý toàn bộ hệ thống API gateway của Kong.\nĐể dễ hình dung, bài viết này sẽ hướng dẫn tạo mới các API và bảo mật cơ bản bằng plugins sử dụng Konga (GUI cho Admin API). Tuy nhiên các bạn có thể dùng curl hay Postman để test. Tài liệu tham khảo: Danh sách các endpoint và tham số của Kong Admin API.\nSau khi cài đặt và đăng nhập vào Konga, chúng ta sẽ kết nối Konga với Kong Admin API (chú ý Active connection):\nThêm mới API Endpoint: Add API\nCác tham số cần thiết:\n name: Tên của API (sử dụng để quản lý API). Ngoài name ra cũng thể dùng id để quản lý API (do hệ thống tự tạo). hosts, uris, methods: Dùng để phân biệt giữa các API, luôn phải có ít nhất 1 trong 3 thuộc tính này. Hosts là phân biệt qua Headers của request, uris là phân biệt qua đường dẫn và methods là phân biệt qua phương thức của request. upstream_url: Đường dẫn gốc của API.    Ví dụ thêm API trỏ đến techmaster.vn qua đường dẫn /techmaster   Các API sẽ chạy qua cổng 8000, trong ví dụ này chúng ta chạy trên localhost nên sẽ truy cập vào localhost:8000. Với cấu hình như ví dụ trên thì khi chúng ta truy cập vào localhost:8000/techmaster, Kong sẽ forward sang trang techmaster.vn. Tuy nhiên đường dẫn một số file như css sẽ bị sai do đường dẫn không bắt đầu từ tên domain (đường dẫn gốc). Do đó nếu sử dụng đường dẫn để phân biệt API thì với ứng dụng web frontend nên dùng cho đường dẫn gốc là /.\nCấu hình plugins Để bảo mật API, chúng ta sẽ cấu hình thêm một số plugins của Kong. Ví dụ để Authentication chúng ta có thể dùng một số plugins như: Basic Authentication, Key Authentication, JWT, \u0026hellip; (một số plugins có nhãn Enterprise sẽ phải trả phí để sử dụng).\nPlugins có thể áp dụng cho toàn bộ API hoặc cho cụ thể từng API qua name hoặc id của chúng. Endpoint Add Plugin.\nVí dụ cấu hình plugin Basic Authentication:\nSau khi kích hoạt Plugin, để truy cập được vào API chúng ta sẽ phải qua một bước Authentication của browser: Nếu user nhập đúng Username và Password thì mới truy cập được vào API. Nếu là gửi request thì trong Headers của request phải có thuộc tính Proxy-Authorization hoặc Authorization có chứa Username và Password được mã hóa base64 theo cú pháp Username:Password.\nTạo Consumer Bước thiếp theo chúng ta phải tạo Consumer để truy cập API. Endpoint Create Consumer.\nTrong Consumer, chúng ta tạo thêm các Credentials tương ứng với các tài khoản truy cập cho Authentication:\nVậy là chúng ta đã cấu hình xong Basic Authentication cho API. Với các Plugins khác thì cũng làm tương tự.\n","permalink":"https://huydq.dev/blog/them-moi-va-bao-mat-api-trong-kong-api-gateway/","summary":"Kong cung cấp một RESTful Admin API cho phép chúng ta thực hiện việc cấu hình và quản lý các API. Mặc định Admin API sẽ lắng nghe ở cổng 8001 và cổng 8444 cho giao thức https. Chú ý API này chỉ dùng trong nội bộ, không public ra ngoài, vì nó cho phép quản lý toàn bộ hệ thống API gateway của Kong.\nĐể dễ hình dung, bài viết này sẽ hướng dẫn tạo mới các API và bảo mật cơ bản bằng plugins sử dụng Konga (GUI cho Admin API).","title":"Thêm mới và bảo mật API trong Kong API Gateway"},{"content":" ASP.NET Core là một open-source web framework mới của Microsoft. Nó cho phép phát triển và chạy ứng dụng web đa nền tảng. Giờ đây bạn có thể lập trình .NET trên cả Linux và MacOS.\n Để lập trình chúng ta có thể sử dụng Visual Studio (trên Windows) hoặc Visual Studio for Mac (trên Mac). Ngoài ra chúng ta cũng có thể dùng Visual Studio Code (VS Code) để lập trình trên cả Windows, MacOS và Linux. VS Code là một Editor hoàn toàn miễn phí và chạy rất nhẹ. Các chức năng của nó cũng khá đầy đủ và có thể cài thêm các Extension để hỗ trợ, bổ sung thêm tính năng tùy vào từng dự án.\nDưới đây là một số cấu hình, tùy chỉnh của mình cho VS Code khi lập trình ASP.NET Core.\n1. Cài đặt Extension Có nhiều Extension hỗ trợ cho việc lập trình ASP.NET Core, tuy nhiên đến thời điểm hiện tại thì có Extension C# (ms-vscode.csharp) là được dùng nhiều nhất và được khuyến cáo sử dụng.\n2. Tùy chỉnh phím tắt Việc thiết lập phím tắt sẽ giúp bạn code nhanh hơn. Chúng ta có thể sửa lại các phím tắt mặc định theo ý mình bằng cách chọn File / Preferences / Keyboard Shortcuts. Tìm đến chức năng muốn thiết lập, chọn biểu tượng Edit hoặc bấm Enter để gán phím tắt cho chức năng đó.\nNếu thiết lập sai (ví dụ bị trùng phím tắt), ta có thể khôi phục lại như cũ bằng cách bấm chuột phải vào chức năng và chọn Reset Keybinding.\n3. Cấu hình Editor VS Code cho phép chúng ta tùy chỉnh việc hiển thị, cách thức làm việc, \u0026hellip; trong phần File / Preferences / Settings. Để cấu hình chúng ta sẽ khai báo các thuộc tính và giá trị trong một file JSON. Chúng ta sẽ copy cấu hình mặc định (Default Setings) sang bên User Settings (hoặc Workspace Settings) với các giá trị mới. Với các cấu hình giống nhau thì VS Code sẽ nhận các giá trị theo mức độ ưu tiên Workspace Settings \u0026gt; User Settings \u0026gt; Default Setings.\n4. Cấu hình launch.json Đây là file cấu hình chạy Debug ứng dụng trên VS Code (nằm trong thư mục .vscode của project). Các bạn có thể tham khảo tài liệu chi tiết ở đây. Với ứng dụng ASP.NET Core thì khi bật Debug, mặc định nó sẽ mở một tab mới trên trình duyệt. Để bỏ chức năng này thì chúng ta sửa lại cấu hình launchBrowser enabled thành false:\n...  \u0026#34;launchBrowser\u0026#34;: {  \u0026#34;enabled\u0026#34;: false,  ...  } ... 5. Cấu hình task.json Task là một chức năng của VS Code cho phép chúng ta tích hợp thêm các External Tools vào trong project như MSbuild, Grunt, Gulp, \u0026hellip; và chúng ta sẽ cấu hình trong file .vscode/task.json. Tham khảo tài liệu chi tiết ở đây.\nTrong project ASP.NET Core thì cần sửa lại cấu hình của msCompile để khi compile lỗi chúng ta có thể chuyển nhanh sang đoạn code gây lỗi.\n  Khi gặp lỗi có thể bấm vào các dòng thông báo để bật nhanh đoạn code bị lỗi   Mặc định msCompile dùng kiểu đường dẫn đầy đủ, nên có thể sẽ gặp lỗi không mở được file:\n  Không mở được file do hiểu nhầm đường dẫn   Sửa lại cấu hình trong file task.json sang kiểu đường dẫn tương đối (relative):\n...  \u0026#34;problemMatcher\u0026#34;: {  \u0026#34;base\u0026#34;: \u0026#34;$msCompile\u0026#34;,  \u0026#34;fileLocation\u0026#34;: [\u0026#34;relative\u0026#34;, \u0026#34;${workspaceRoot}\u0026#34;]  } ... Trên đây là một số kinh nghiệm của mình khi thiết lập môi trường làm việc ASP.NET Core với Visual Studio Code. Các bạn có thể tham khảo để setup cho mình một môi trường phát triển tiện lợi và phù hợp nhất.\nHappy Coding 😁 .\n","permalink":"https://huydq.dev/blog/tuy-chinh-visual-studio-code-khi-lap-trinh-aspnet-core/","summary":"ASP.NET Core là một open-source web framework mới của Microsoft. Nó cho phép phát triển và chạy ứng dụng web đa nền tảng. Giờ đây bạn có thể lập trình .NET trên cả Linux và MacOS.\n Để lập trình chúng ta có thể sử dụng Visual Studio (trên Windows) hoặc Visual Studio for Mac (trên Mac). Ngoài ra chúng ta cũng có thể dùng Visual Studio Code (VS Code) để lập trình trên cả Windows, MacOS và Linux.","title":"Tùy chỉnh Visual Studio Code khi lập trình ASP.NET Core"},{"content":"Thông thường khi làm dự án với Entity Framework, chúng ta hay dùng cơ sở dữ liệu (CSDL) MS SQL Server. Tuy nhiên tùy theo yêu cầu công việc, bạn có thể sẽ phải làm việc với các cơ sở dữ liệu khác. Bài viết này mình sẽ chia sẻ 1 số kinh nghiệm của bản thân khi phải làm việc với CSDL Oracle (cụ thể là Oracle phiên bản 11g).\nCài đặt provider Để cài đặt provider thì chúng ta có thể cài đặt qua NuGet hoặc download trên trang chủ của Oracle. Nhưng do tính chất công việc cần bảo mật, mình không được sử dụng internet nên chọn cách sử dụng bộ cài ODAC trên Oracle: http://www.oracle.com/technetwork/topics/dotnet/utilsoft-086879.html. Các bạn có thể sử dụng phiên bản ODAC 11.2 trở lên, ở đây mình dùng hẳn luôn bản mới ODAC 12c Release 4 vì nó có tính tương thích ngược.\nĐể cài ODAC thì các bạn chỉ cần giải nén file tải về và chạy tệp setup.exe (Oracle Universal Installer), nhưng sẽ có 1 số lưu ý sau:\n  Nếu trên máy đã có ODAC bản cũ thì cần gỡ ra trước khi cài mới bằng cách sử dụng Universal Installer (Windows Start Menu \u0026ndash;\u0026gt; All Programs \u0026ndash;\u0026gt; Oracle - \u0026ndash;\u0026gt; Oracle Installation Products \u0026ndash;\u0026gt; Universal Installer).\n  Khi cài đến phần chọn thư mục cài đặt (Specify Installation Location) thì cần chú ý trong đường dẫn không được phép chứa các ký tự đặc biệt (ví dụ như dấu cách). Có thể lúc cài thì vẫn cài được nhưng sau đó sẽ bị lỗi (mình đã bị dính lỗi này khi sử dụng Windows Built-in Account có username chứa dấu cách).\n  Một số khác biệt khi sử dụng CSDL Oracle   Trong Oracle không dùng khái niệm database như các CSDL khác mà sử dụng khái niệm Schemas, và Schemas tương ứng với Users. Tức là ở trong MS SQL Server chúng ta tạo mới một database thì ở đây chúng ta tạo mới một user (schema). Ví dụ chúng ta cần tạo một ứng dụng quản lý sinh viên thì thay vì tạo database student, chúng ta tạo mới một user tên là student.\n  Tất cả tên bảng trong schema không được vượt quá 30 ký tự.\n  Lỗi ORA-01918: user \u0026ldquo;dbo\u0026rdquo; does not exist khi sử dụng EF Migration, đó là do Oracle hiểu nhầm dbo.table_name là bảng table_name trong schema dbo. Sửa bằng cách đổi lại schema trong class DbContext bằng cách ghi đè phương thức OnModelCreating, ví dụ schema của mình là ROBIN (chú ý viết hoa):\n  public class ApplicationDbContext : IdentityDbContext {  public ApplicationDbContext() : base(\u0026#34;ROBIN\u0026#34;, throwIfV1Schema: false)  {  }   public static ApplicationDbContext Create()  {  return new ApplicationDbContext();  }   protected override void OnModelCreating(DbModelBuilder modelBuilder)  {  base.OnModelCreating(modelBuilder);  modelBuilder.HasDefaultSchema(\u0026#34;ROBIN\u0026#34;);  } } Hy vọng một số kinh nghiệm trên đây sẽ giúp những ai mới làm việc với Oracle giảm bớt thời gian tìm hiểu cài đặt hay fix những bug kể trên.\n","permalink":"https://huydq.dev/blog/su-dung-co-so-du-lieu-oracle-voi-entity-framework/","summary":"Thông thường khi làm dự án với Entity Framework, chúng ta hay dùng cơ sở dữ liệu (CSDL) MS SQL Server. Tuy nhiên tùy theo yêu cầu công việc, bạn có thể sẽ phải làm việc với các cơ sở dữ liệu khác. Bài viết này mình sẽ chia sẻ 1 số kinh nghiệm của bản thân khi phải làm việc với CSDL Oracle (cụ thể là Oracle phiên bản 11g).","title":"Sử dụng cơ sở dữ liệu Oracle với Entity Framework"},{"content":"Bài trước mình đã hướng dẫn cách tạo chứng chỉ SSL miễn phí với Let\u0026rsquo;s Encrypt. Tiếp theo mình sẽ hướng dẫn các bạn cách tạo chứng chỉ SSL qua dịch vụ của Namecheap (mất phí nhé 😂)\nĐăng ký dịch vụ của Namecheap\nĐầu tiên chúng ta sẽ cần đăng ký tài khoản tại Namecheap và chọn 1 loại chứng chỉ phù hợp https://www.namecheap.com/security/ssl-certificates.aspx\nSau khi đã thanh toán, truy cập vào Dashboard để active dịch vụ\n  Di chuột đến phần tên user góc trên bên phải để truy cập Dashboard     Trên menu chọn phần Product List / SSL Certificates     Chọn ACTIVATE để kích hoạt dịch vụ   Tiếp theo để kích hoạt dịch vụ chúng ta sẽ cần điền một CSR (Certificate Signing Request), đó là 1 đoạn code mã hóa thông tin về công ty và tên miền. Để tạo mã CSR, chúng ta cần truy cập vào server và gõ lệnh sau:\n$ openssl req -new -newkey rsa:2048 -nodes -keyout server.key -out server.csr Khi trên server có nhiều website thì chúng ta nên thay server.key và server.csr bằng tên miền để tránh nhầm lẫn, ví dụ nctest.info.key và nctest.info.csr hoặc lưu vào 1 thư mục riêng ví dụ /etc/ssl/nctest.info\nKhi thực hiện lệnh, chúng ta sẽ phải điền 1 số thông tin của công ty và domain ví dụ như sau:\nCountry Name (2 letter code) [AU]: VN State or Province Name (full name) [Some-State]: Hanoi Locality Name (eg, city) []: Hanoi Organization Name (eg, company) [Internet Widgits Pty Ltd]: NCTEST Ltd Organizational Unit Name (eg, section) []: Training Common Name (e.g. server FQDN or YOUR name) []: nctest.info Email Address []: administrator@nctest.info Kết quả chúng ta sẽ có 2 file là server.key (Private Key) và server.csr (mã CSR). File server.key sẽ dùng để chứng thực nên cần lưu lại cẩn thận để dùng đến sau này. File server.csr sẽ dùng để gửi dữ liệu lên namecheap, chúng ta dùng lệnh sau để đọc nội dung file và copy để điền vào form đăng ký cat server.csr\n  Copy mã CSR và điền vào form, chọn Web-Server Nginx sau đó Submit   Phần nào không điền được thì có thể để \u0026lsquo;NA\u0026rsquo; và chú ý chỉ sử dụng ký tự alphabet, tiếng Anh không dấu.\nChọn phương thức xác thực\nCó 3 loại phương thức xác thực là Email, HTTP-based và DNS-based. Ở đây mình sẽ hướng dẫn theo cách đầu tiên là xác thực qua Email, 2 cách còn lại các bạn xem hướng dẫn tiếng Anh tại website.\n  Ví dụ xác thực qua Email       Xác nhận gửi email   Xong, tiếp theo chúng ta chờ Namecheap gửi email xác thực và chứng chỉ SSL qua email đăng ký (ví dụ admin@nctest.info).\nChứng chỉ SSL sẽ được đính kèm theo email, tải về và upload lên server và giải nén chúng ta sẽ được 2 file dạng như sau nctest.info.crt và nctest.info.ca-bundle, nối 2 file lại bằng lệnh cat (nếu có nhiều file hơn thì cũng nối lại thành 1 file tương tự):\n$ cat nctest.info.crt nctest.info.ca-bundle \u0026gt;\u0026gt; cert_chain.crt Chúng ta sẽ sử dụng file đã nối là cert_chain.crt và file Private key tạo lúc ban đầu là server.key để cài đặt SSL.\nCấu hình Nginx\nSửa file cấu hình cho domain, nếu chưa lắng nghe ở cổng 443 thì bổ sung thêm, và trỏ đường dẫn vào 2 file cert_chain.crt và server.key:\nserver { listen 443; ssl on; ssl_certificate /etc/ssl/nctest.info/cert_chain.crt; ssl_certificate_key /etc/ssl/nctest.info/server.key; server_name nctest.info; access_log /var/log/nginx/nginx.vhost.access.log; error_log /var/log/nginx/nginx.vhost.error.log; location / { root /var/www/; index index.html; } } Hoặc tham khảo file cấu hình ở bài hướng dẫn trước. Sau khi sửa xong nhớ khởi động lại Nginx và hưởng thụ thành quả 😊\n","permalink":"https://huydq.dev/blog/cai-dat-chung-chi-ssl-cua-namecheap-voi-nginx/","summary":"Bài trước mình đã hướng dẫn cách tạo chứng chỉ SSL miễn phí với Let\u0026rsquo;s Encrypt. Tiếp theo mình sẽ hướng dẫn các bạn cách tạo chứng chỉ SSL qua dịch vụ của Namecheap (mất phí nhé 😂)\nĐăng ký dịch vụ của Namecheap\nĐầu tiên chúng ta sẽ cần đăng ký tài khoản tại Namecheap và chọn 1 loại chứng chỉ phù hợp https://www.namecheap.com/security/ssl-certificates.aspx\nSau khi đã thanh toán, truy cập vào Dashboard để active dịch vụ","title":"Cài đặt chứng chỉ SSL của Namecheap với Nginx"},{"content":"Hiện nay hầu hết các trang web đều đã hỗ trợ SSL (Secure Socket Layer). Nó mã hóa dữ liệu truyền đi giữa máy chủ web và trình duyệt và làm tăng tính bảo mật cho website. Ngoài ra, việc sử dụng SSL certificate (chứng chỉ SSL) là cần thiết bởi hiện tại Google đã ưu tiên xếp hạng website dựa theo giao thức https (HTTP + SSL), những website mà chỉ sử dụng giao thức http sẽ bị coi là \u0026ldquo;unsafe\u0026rdquo; (không an toàn).\nCó nhiều loại chứng chỉ SSL cung cấp các mức độ bảo mật khác nhau. Ví dụ chúng ta có thể mua một Chứng chỉ SSL tại Namecheap với các mức giá khác nhau tùy từng loại. Tuy nhiên trong bài viết này chúng ta sẽ chỉ nói đến loại cơ bản nhất và làm thế nào để có được nó một cách miễn phí 😁\nMột số cách để có chứng chỉ SSL miễn phí\n  Sử dụng Cloudflare: Đây là một website cung cấp dịch vụ tăng tốc và bảo mật website, họ có cung cấp chứng chỉ SSL ở gói Free. Việc đăng ký rất dễ dàng nên mình sẽ không hướng dẫn ở đây. Chú ý là với website chỉ phục vụ người dùng tại Việt Nam thì chạy qua Cloudflare có thể sẽ chậm hơn 1 chút do sử dụng CDN server ngoài Việt Nam.\n  Sử dụng Let\u0026rsquo;s Encrypt: Sử dụng dịch vụ này chúng ta sẽ tự tạo SSL certificate cho riêng mình và hoàn toàn miễn phí.\n  Cách tạo SSL certificate với Let\u0026rsquo;s Encrypt\nGiả sử chúng ta đang sử dụng 1 server Ubuntu với tài khoản truy cập có quyền sudo và sử dụng web server là Nginx.\nBước 1: Cài đặt gói letsencrypt (với bản mới sẽ đổi tên là certbot và dùng lệnh certbot thay cho letsencrypt)\n$ sudo apt-get update $ sudo apt-get install letsencrypt hoặc làm theo hướng dẫn tại trang chủ https://certbot.eff.org/\nBước 2: Tạo SSL certificate\n Thêm đoạn cấu hình sau vào block server của file cấu hình cho website (thường nằm trong /etc/nginx/sites-enabled hoặc /etc/nginx/conf.d) để cho phép truy cập vào thư mục ẩn (.well-known) phục vụ cho việc xác thực:  ... location ~ /.well-known { allow all; } ...  Kiểm tra lại cấu hình xem có sai cú pháp chỗ nào không bằng lệnh:  $ nginx -t  Nếu có báo lỗi thì sửa theo hướng dẫn, sau đó khởi động lại Nginx:  $ sudo systemctl restart nginx  Tạo SSL certificate (thay example.com bằng tên miền của bạn và /var/www/example.com là đường dẫn đến thư mục gốc của website):  $ sudo letsencrypt certonly -a webroot --webroot-path=/var/www/example.com -d example.com -d www.example.com  Nếu thành công output sẽ trông như sau:  IMPORTANT NOTES: - If you lose your account credentials, you can recover through e-mails sent to sammy@digitalocean.com - Congratulations! Your certificate and chain have been saved at /etc/letsencrypt/live/example.com/fullchain.pem. Your cert will expire on 2016-03-15. To obtain a new version of the certificate in the future, simply run Let\u0026#39;s Encrypt again. ... Bước 3: Cấu hình SSL cho website\n Để tăng tính bảo mật, tạo Strong Diffie-Hellman Group:  $ sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048  Tạo 1 snippet cho Nginx để có thể tái sử dụng được khi muốn cấu hình cho nhiều website:  $ sudo nano /etc/nginx/snippets/ssl-params.conf Nội dung file như sau:\nssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ssl_ciphers \u0026#34;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\u0026#34;; ssl_ecdh_curve secp384r1; ssl_session_cache shared:SSL:10m; ssl_stapling on; ssl_stapling_verify on; ssl_dhparam /etc/ssl/certs/dhparam.pem; resolver 8.8.8.8 8.8.4.4 valid=300s; resolver_timeout 5s; add_header Strict-Transport-Security \u0026#34;max-age=63072000; includeSubdomains\u0026#34;; add_header X-Frame-Options DENY; add_header X-Content-Type-Options nosniff; Tham khảo cấu hình SSL bảo mật tại https://cipherli.st/ và https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html\n Sửa file cấu hình cho website:  Tạo redirect 301 cho block server listen 80 (http) nếu bạn chỉ muốn support https (khi người dùng truy cập với giao thức http sẽ tự động chuyển thành https)\nserver { listen 80; server_name example.com www.example.com; return 301 https://$server_name$request_uri; } Tạo thêm 1 block server listen 443 (https)\nserver { listen 443 ssl http2; server_name example.com www.example.com; ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem; include snippets/ssl-params.conf; root /var/www/example.com; location ~ /.well-known { allow all; } } Chú ý thay toàn bộ example.com bằng domain của mình và đường dẫn root /var/www/example.com giống bước tạo SSL certificate.\n Sau khi cấu hình xong thì khởi động lại Nginx:  $ sudo systemctl restart nginx  Truy cập thử website để xem thành quả hoặc kiểm tra bằng trang sau https://www.ssllabs.com/ssltest/analyze.html  Gia hạn SSL certificate\n SSL tạo theo cách này sẽ hết hạn sau 90 ngày và chúng ta sẽ phải gia hạn bằng lệnh sau:  $ sudo letsencrypt renew Để tự động hóa việc này chúng ta có thể cấu hình cronjob để tự động gia hạn chứng chỉ.\n Ví dụ cấu hình cronjob để tự động gia hạn mỗi 60 ngày:  $ sudo crontab -e Thêm vào dòng sau (đặt lịch cứ mỗi 2 tháng tự động chạy lệnh renew vào lúc 0h30):\n30 0 1 */2 * /usr/bin/letsencrypt renew \u0026amp;\u0026amp; /bin/systemctl reload nginx Xong, vậy là website của chúng ta đã có thể truy cập qua giao thức https và không lo bị hết hạn 👍.\n","permalink":"https://huydq.dev/blog/chung-chi-ssl-mien-phi-voi-lets-encrypt/","summary":"Hiện nay hầu hết các trang web đều đã hỗ trợ SSL (Secure Socket Layer). Nó mã hóa dữ liệu truyền đi giữa máy chủ web và trình duyệt và làm tăng tính bảo mật cho website. Ngoài ra, việc sử dụng SSL certificate (chứng chỉ SSL) là cần thiết bởi hiện tại Google đã ưu tiên xếp hạng website dựa theo giao thức https (HTTP + SSL), những website mà chỉ sử dụng giao thức http sẽ bị coi là \u0026ldquo;unsafe\u0026rdquo; (không an toàn).","title":"Chứng chỉ SSL miễn phí với Let's Encrypt"},{"content":"Ở bài trước mình có hướng dẫn cài đặt Gitlab trên Private Server, tuy nhiên cách cài này là cài trực tiếp lên server, có thể sẽ xung đột với các gói phần mềm có sẵn như: Redis, Nginx, \u0026hellip; Do đó bài này chúng ta sẽ thử cài Gitlab qua Docker - một công nghệ đang rất hot trong thời điểm hiện tại.\nViệc đầu tiên chúng ta phải làm đó là cài đặt Docker, các bạn tham khảo tại đây, hướng dẫn này rất chi tiết rồi mình sẽ không nhắc lại nữa.\nSau khi cài xong Docker, chúng ta chỉ việc bật terminal lên và gõ\n$ docker run -d --name local-gitlab --restart always -p 80:80 gitlab/gitlab-ce Giải thích 1 chút về câu lệnh trên:\n docker run -d: Khởi tạo và chạy 1 Container cho Gitlab dưới dạng Detached mode (có thể hình dung như 1 máy ảo, trong máy ảo đó có Gitlab) \u0026ndash;name local-gitlab: Đặt tên cho Container là local-gitlab, sau này chúng ta sẽ tương tác với Container qua tên này. \u0026ndash;restart always: Luôn luôn khởi động lại Container khi bị thoát (khi server reboot hay restart docker service) -p 80:80: Publish port 80 từ trong Container ra ngoài host để chúng ta có thể truy cập vào gitlab qua host, chúng ta cũng có thể publish ra 1 cổng khác ví dụ -p 8080:80, nếu là trên localhost thì truy cập vào gitlab như sau http://localhost:8080 gitlab/gitlab-ce: Tên của một Image trên https://hub.docker.com (cái này tương tự như Github nhưng thay vì chứa source code thì nó chứa các Image - các bản đóng gói do người khác upload lên). Chúng ta cũng có thể dùng một Image khác bằng cách search ở trên Docker hub (nên chọn Image có STARS cao và nhiều lượt PULL)  Sau khi câu lệnh chạy xong là việc cài Gitlab cũng đã hoàn tất, tuy nhiên chúng ta sẽ phải chờ thêm một vài phút để Gitlab hoàn thiện việc cấu hình. Nếu nóng lòng truy cập ngay có thể gặp lỗi như sau:\n  Nếu gặp lỗi này chỉ cần chờ 1 lúc rồi Refresh trang là được 😬   Vậy là với Docker, chúng ta có thể cài Gitlab chỉ trong 1 nốt nhạc. Còn nếu bạn muốn cấu hình cho Gitlab thì có thể dùng lệnh docker exec, ví dụ muốn sửa file cấu hình của gitlab thì chúng ta gõ lệnh sau:\n$ docker exec -it local-gitlab vim /etc/gitlab/gitlab.rb lệnh trên sẽ bật file /etc/gitlab/gitlab.rb​ trong Container gitlab bằng vim (nếu không thích dùng vim thì thay bằng nano cũng được)\nSau khi cấu hình xong thì phải restart lại Container bằng lệnh:\n$ docker restart local-gitlab Tham khảo thêm về các câu lệnh của Docker tại đây\n","permalink":"https://huydq.dev/blog/cai-dat-gitlab-bang-docker/","summary":"Ở bài trước mình có hướng dẫn cài đặt Gitlab trên Private Server, tuy nhiên cách cài này là cài trực tiếp lên server, có thể sẽ xung đột với các gói phần mềm có sẵn như: Redis, Nginx, \u0026hellip; Do đó bài này chúng ta sẽ thử cài Gitlab qua Docker - một công nghệ đang rất hot trong thời điểm hiện tại.\nViệc đầu tiên chúng ta phải làm đó là cài đặt Docker, các bạn tham khảo tại đây, hướng dẫn này rất chi tiết rồi mình sẽ không nhắc lại nữa.","title":"Cài đặt Gitlab bằng Docker"},{"content":"Gitlab là một công cụ để quản lý source code rất nổi tiếng hiện nay. Nó cho phép chúng ta tạo và quản lý các Git source repository tương tự nhu trên Github, tuy nhiên nó cho phép chúng ta tạo không giới hạn các private repository và nhiều chức năng thú vị khác như: code reviews, issue tracking, activity feeds, wikis, \u0026hellip;\nChúng ta có thể sử dụng gitlab bằng cách truy cập trang https://gitlab.com hoặc cài gitlab lên 1 server riêng. Có 2 cách để cài gitlab lên private server đó là: Cài từ source git và cài theo Omnibus package. Cài theo cách thứ 2 thì sẽ đơn giản hơn rất nhiều, chúng ta chỉ cần vào mục download, sau đó chọn server cần cài đặt và làm theo các bước hướng dẫn bên dưới.\n  Ví dụ cài Gitlab lên server Debian 8   Tóm tắt các lệnh cài đặt trên server Debian 8\n$ sudo apt-get install curl openssh-server ca-certificates postfix $ curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash $ sudo apt-get install gitlab-ce $ sudo gitlab-ctl reconfigure Sau khi cài đặt xong chúng ta có thể dùng gitlab-ctl để quản lý service:\n# Kiểm tra trạng thái $ sudo gitlab-ctl status # Bật gitlab $ sudo gitlab-ctl start # Tắt gitlab $ sudo gitlab-ctl stop # Khởi động lại gitlab $ sudo gitlab-ctl restart Chú ý\n  Gitlab Omnibus bao gồm nhiều gói package bên trong như: Nginx, Postgresql, Redis, Sidekiq, Unicorn, .. nên dung lượng khá nặng\n  Nếu trên server đang sử dụng Nginx làm web server thì có thể bị trùng cổng. Chúng ta có thể disable gói Nginx trong Gitlab Omnibus đi để dùng Nginx có sẵn:\n  Bật file /etc/gitlab/gitlab.rb và sửa các cấu hình sau:\nnginx[\u0026#39;enable\u0026#39;] = false web_server[\u0026#39;external_users\u0026#39;] = [\u0026#39;www-data\u0026#39;]```   Cập nhật lại cấu hình của Gitlab\n$ gitlab-ctl reconfigure   Cấu hình lại Nginx cho Gitlab, có thể tham khảo file cấu hình mẫu tại đây\n  Cấu hình gửi email SMTP, có thể tham khảo tại đây\n  Tham khảo document của Gitlab Omnibus: https://docs.gitlab.com/omnibus/​\n","permalink":"https://huydq.dev/blog/huong-dan-cai-dat-gitlab-tren-private-server/","summary":"Gitlab là một công cụ để quản lý source code rất nổi tiếng hiện nay. Nó cho phép chúng ta tạo và quản lý các Git source repository tương tự nhu trên Github, tuy nhiên nó cho phép chúng ta tạo không giới hạn các private repository và nhiều chức năng thú vị khác như: code reviews, issue tracking, activity feeds, wikis, \u0026hellip;\nChúng ta có thể sử dụng gitlab bằng cách truy cập trang https://gitlab.","title":"Hướng dẫn cài đặt Gitlab trên Private Server"},{"content":"Khi sử dụng thẻ img để chèn ảnh vào trang web, có 1 hiện tượng khá thú vị mà không phải ai cũng biết hoặc để ý đến. Đó là nếu bọc thẻ img bởi 1 thẻ div (hoặc bất kỳ 1 thẻ nào khác) thì sẽ xuất hiện 1 khoảng trắng nhỏ ở bên dưới ảnh.\nNếu chúng ta thiết lập padding cho thẻ div thì do khoảng trắng này mà khoảng cách phần bên dưới vẫn lớn hơn phần bên trên. Vậy khoảng trắng này từ đâu mà có?\nĐể hiểu rõ về vấn đề này, chúng ta phải nắm rõ về HTML CSS, đặc biệt là khái niệm về Inline element và Block element.\nMặc định thẻ img trong HTML là một Inline element, tức là nó được coi như là text. Do đó nó sẽ được browser xử lý như với text thông thường. Đến đây ta lại phải biết một chút về text, một số khái niệm về text trong kỹ thuật in ấn:\n Trên cùng 1 dòng, các chữ cái sẽ nằm trên một đường thẳng gọi là baseline(đó cũng là giá trị mặc định của thuộc tính vertical-align trong CSS) Một số chữ cái, ký tự đặc biệt sẽ có 1 phần nằm dưới baseline ví dụ như y, j, p, g, \u0026hellip; và phần nằm dưới đó gọi là descenders(tương tự, có 1 phần nằm trên text gọi là ascenders)   Do đó trình duyệt sẽ tạo ra 1 khoảng trắng dành cho phần descenders của text, nếu chúng ta viết thêm 1 vài ký tự có descenders vào bên cạnh ảnh và tăng font-size của chúng lên, ta sẽ thấy rõ tại sao lại có khoảng trắng nhỏ bên dưới ảnh.\nVậy là chúng ta đã khám phá được khoảng trắng bí ẩn bên dưới thẻ img. Và để xử lý khoảng trắng đó ta có thể dùng các cách sau:\n Dùng thuộc tính vertical-align cho thẻ img với giá trị là middle. Dùng thuộc tính line-height cho thẻ div với giá trị là 0. Chuyển img thành Block element với thuộc tính display.  ","permalink":"https://huydq.dev/blog/khoang-trang-bi-an-ben-duoi-the-img/","summary":"Khi sử dụng thẻ img để chèn ảnh vào trang web, có 1 hiện tượng khá thú vị mà không phải ai cũng biết hoặc để ý đến. Đó là nếu bọc thẻ img bởi 1 thẻ div (hoặc bất kỳ 1 thẻ nào khác) thì sẽ xuất hiện 1 khoảng trắng nhỏ ở bên dưới ảnh.\nNếu chúng ta thiết lập padding cho thẻ div thì do khoảng trắng này mà khoảng cách phần bên dưới vẫn lớn hơn phần bên trên.","title":"Khoảng trắng bí ẩn bên dưới thẻ Img"},{"content":"\u0026hellip; tiếp theo 29 câu lệnh Linux bạn nên biết phần 1\n17. help \u0026ndash;help xem thông tin trợ giúp và các tùy chỉnh của câu lệnh.\nCó thể viết tắt là -h\n18. whatis – What is this command whatis hiển thị mô tả về câu lệnh.\n19. man – Manual man ​ hiển thị trang hướng dẫn cho câu lệnh.\n20. exit exit ​ thoát khỏi phiên làm việc. Tương tự như việc thoát khỏi một ứng dụng trên giao diện người dùng.\n21. ping ping \u0026lt;địa chỉ host\u0026gt; ​ ping một host từ xa (server) bằng cách gửi các gói tin đến host đó. Nó thường dùng để kiểm tra kết nối mạng đến server.\nTham khảo các khóa học lập trình online, onlab, và thực tập lập trình tại TechMaster\n22. who – Who Is logged in who ​ hiển thị danh sách các tài khoản đang đăng nhập vào hệ thống.\n23. su – Switch User su ​ chuyển sang đăng nhập bằng một tài khoản khác. Tài khoản root có thể chuyển sang đăng nhập bằng các tài khoản khác mà không cần nhập mật khẩu.\n24. uname uname ​ hiển thị ra một số thông tin hệ thống như tên kernel, tên host, bộ xử lý, \u0026hellip;\nBạn có thể dùng lệnh uname -a ​ để hiển thị tất cả thông tin.\n25. free – Free memory free ​ xem thông tin về bộ nhớ: bộ nhớ đã sử dụng, bộ nhớ còn trống trên hệ thống\nBạn có thể dùng lệnh free -m ​ để xem bộ nhớ với đơn vị KBs hoặc free -g ​ để xem với đơn vị GBs\n26. df – Disk space Free df ​ xem thông tin về dung lượng đĩa cứng (đã sử dụng, còn trống, \u0026hellip;) và các thiết bị lưu trữ khác.\nBạn có thể dùng lệnh df -h ​ để xem thông tin dưới dạng human readable (hiển thị với đơn vị KBs, GBs cho dễ đọc).\n27. ps – Processes ps ​ hiển thị thông tin về các tiến trình đang chạy.\n28. top – Top processes top ​ hiển thị thông tin về các tiến trình đang chạy, sắp xếp theo hiệu suất CPU.\nBạn cũng có thể dùng lệnh top -u ​ để xem thông tin các tiến trình đang chạy của tài khoản đó.\n29. shutdown shutdown ​ lệnh tắt máy tính. Có thể dùng shutdown -r để khởi động lại máy tính.\nNguồn: http://www.hongkiat.com/blog/basic-linux-commands/\n","permalink":"https://huydq.dev/blog/29-cau-lenh-linux-ban-nen-biet-phan-2/","summary":"\u0026hellip; tiếp theo 29 câu lệnh Linux bạn nên biết phần 1\n17. help \u0026ndash;help xem thông tin trợ giúp và các tùy chỉnh của câu lệnh.\nCó thể viết tắt là -h\n18. whatis – What is this command whatis hiển thị mô tả về câu lệnh.\n19. man – Manual man ​ hiển thị trang hướng dẫn cho câu lệnh.\n20. exit exit ​ thoát khỏi phiên làm việc.","title":"29 câu lệnh Linux bạn nên biết - Phần 2"},{"content":"Các bản phân phối Linux đều có hỗ trợ giao diện người dùng để tương tác với máy tính. Tuy nhiên trong một số trường hợp sử dụng giao diện command line để điều khiển máy tính sẽ nhanh hơn và đơn giản hơn.\nTrong giao diện command line, các câu lệnh (command) dùng để ra chỉ thị cho máy tính thực hiện một tác vụ nào đó. Bạn có thể sử dụng câu lệnh để tắt máy tính, xem danh sách các file trong thư mục, sao chép file, di chuyển và xóa file, \u0026hellip;\nDưới đây tôi sẽ liệt kê các câu lệnh Linux cơ bản thường gặp để các bạn mới làm quen với Linux hoặc các quản trị viên Linux có thể dễ dàng học tập, tra cứu.\n1. ls - List ls liệt kê nội dung (file và thư mục) trong thư mục hiện hành. Nó cũng tương tự với việc bạn mở một thư mục và xem nội dung trong đó trên giao diện người dùng.\n2. mkdir - Make Directory mkdir tạo một thư mục mới. Nó cũng tương tự với việc bạn chọn new/create directory để tạo một thư mục mới trên giao diện người dùng.\n3. pwd - Print Working Directory pwd in ra đường dẫn đầy đủ đến thư mục hiện hành.\n4. cd - Change Directory cd chuyển một thư mục thành thư mục hiện hành cho phiên làm việc hiện tại. Nó cũng tương tự với việc bạn mở một thư mục và thao tác với các file và thư mục bên trong đó trên giao diện người dùng.\n5. rmdir - Remove Directory rmdir xóa một thư mục.\n6. rm - Remove rm xóa file. Bạn cũng có thể sử dụng rm -r để xóa thư mục và toàn bộ dữ liệu trong thư mục đó.\n7. cp - Copy cp sao chép file từ vị trí nguồn đến vị trí đích.\nBạn cũng có thể sử dụng cp -r để sao chép thư mục và toàn bộ dữ liệu bên trong.\n8. mv - Move mv \u0026lt;đích\u0026gt; di chuyển một file hoặc thư mục từ vị trí này sang vị trí khác. Lệnh này cũng dùng để đổi tên file hoặc thư mục nếu như và \u0026lt;đích\u0026gt; là cùng một thư mục.\n9. cat – concatenate and print files cat đọc và in ra nội dung của file ra màn hình.\n10. tail – print TAIL tail đọc và in ra nội dung 10 dòng cuối cùng của file (mặc định).\nBạn có thể sử dụng tail -n N để chỉ định in N dòng ra màn hình.\n11. less – print LESS less in ra nội dung của một file theo từng trang trong trường hợp nội dung của file quá lớn và phải đọc theo trang. Bạn có thể dùng Ctrl+F để chuyển trang tiếp theo và Ctrl+B để chuyển về trang trước.\n12. grep grep tìm kiếm nội dung của file theo chuỗi cung cấp.\nBạn có thể dùng grep -i để tìm kiếm không phân biệt hoa thường hoặc grep -r để tìm kiếm trong toàn thư mục\n13. find find -name tìm kiếm file trong theo .\nBạn cũng có thể dùng find -iname để tìm kiếm không phân biệt hoa thường.\n14. tar tar -cvf tạo file nén (.tar) từ các file có sẵn.\ntar -tvf xem nội dung file nén (.tar).\ntar -xvf giải nén (file .tar).\n15. gzip gzip tạo file nén (.gz). Sử dụng gzip -d để giải nén (file .gz).\n16. unzip unzip giải nén một file nén (.zip). Sử dụng unzip -l để xem nội dung file zip mà không cần giải nén.\nPhần tiếp theo: 29 câu lệnh Linux bạn nên biết - Phần 2\n","permalink":"https://huydq.dev/blog/29-cau-lenh-linux-ban-nen-biet-phan-1/","summary":"Các bản phân phối Linux đều có hỗ trợ giao diện người dùng để tương tác với máy tính. Tuy nhiên trong một số trường hợp sử dụng giao diện command line để điều khiển máy tính sẽ nhanh hơn và đơn giản hơn.\nTrong giao diện command line, các câu lệnh (command) dùng để ra chỉ thị cho máy tính thực hiện một tác vụ nào đó. Bạn có thể sử dụng câu lệnh để tắt máy tính, xem danh sách các file trong thư mục, sao chép file, di chuyển và xóa file, \u0026hellip;","title":"29 câu lệnh Linux bạn nên biết - Phần 1"},{"content":"Hi there 👋\nCảm ơn bạn đã ghé thăm blog của mình, một blog về công nghệ (chủ yếu là lập trình), nhưng cũng có thể có nhiều bài viết linh tinh nhảm nhí tùy hứng của tác giả.\nHy vọng các bài viết ở đây sẽ giúp phần nào cho công việc của các bạn (nếu bạn là lập trình viên), hoặc ít nhất nó cũng giúp bạn giải trí sau những giờ làm việc căng thẳng 😎.\n","permalink":"https://huydq.dev/about/","summary":"Hi there 👋\nCảm ơn bạn đã ghé thăm blog của mình, một blog về công nghệ (chủ yếu là lập trình), nhưng cũng có thể có nhiều bài viết linh tinh nhảm nhí tùy hứng của tác giả.\nHy vọng các bài viết ở đây sẽ giúp phần nào cho công việc của các bạn (nếu bạn là lập trình viên), hoặc ít nhất nó cũng giúp bạn giải trí sau những giờ làm việc căng thẳng 😎.","title":"About"},{"content":"Coming soon \u0026hellip; ","permalink":"https://huydq.dev/projects/","summary":"Coming soon \u0026hellip; ","title":"Projects"}]